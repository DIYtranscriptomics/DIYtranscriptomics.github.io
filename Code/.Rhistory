install.packages("dplyr")
install.packages("knitr")
install.packages("ggplot2")
setRepositories()
install.packages("limma")
install.packages(c("limma", "lumi", "oligo", "dplyr", "ggplot2", "knitr"))
install.packages(c("limma", "lumi", "methylumi", "lumiHumanAll.db", "lumiMouseAll.db", "lumiHumanIDMapping", "lumiMouseIDMapping", "Annotate", "biomart", "oligo", "dplyr", "stringr", "reshape2", "sqldf", "biostrings", "GenomicRanges", "RColorbrewer", "ggplot2", "ggbio", "heatmap.2", "heatmap.3", "heatplus", "heatmap.plus", "knitr", "RCharts", "RCircus", "DESeq2", "EdgeR", "ChipPeakAnno", "Vegan", "Phyloseq", "HMP", "ROCR"))
install.packages("igraph")
install.packages("scatterplot3d")
save.image()
getwd()
X = 5
Y = 10
x * Y
x <- 45
y <- 13
x*y
library("limma")
package?limma
??limma
?limma
help(limma)
?limma
?decideTests
limma?
library("limma")
detach("package:limma", unload=TRUE)
library("limma", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
?limma
?decideTest
?decideTests
1 + 5
answer <- 1+5
answer2 <- 1 + 5
answer
answer2
class(answer)
dim(answer)
shiny::runApp('Box Sync/TLX_macrophage/Microarray_TLX_FetalLiver')
---
source("http://bioconductor.org/biocLite.R")
biocLite()
library("rmarkdown", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
remove.packages("rmarkdown")
install.packages("rmarkdown")
library("rmarkdown", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
shiny::runApp('Git/TranscriptomicsWorkshop.github.io/RNAseqWeb-app')
shiny::runApp('Git/TranscriptomicsWorkshop.github.io/studentProjects/Novais_app')
heatmap.2(diffData.LPSko.AVG, Rowv=as.dendrogram(hr.LPSko), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSko,
cexRow=1, cexCol=1, margins=c(8,20))
setwd("~/Git/TranscriptomicsWorkshop.github.io/R_scripts")
# Introduction to this script -----------
#This script carries out the steps involved in analysis of RNAseq data.
#depending on your data and interests, different parts of this script may not apply to you
# Loading packages -----------------------------------------------
#begin by loading the packages required for RNAseq data
library(Rsubread) #package that I use for read alignment and summarization. NOTE: this package ONLY available for Mac
library(limma) #comprehensive package for using linear models to analyze gene expression data
library(edgeR) #comprehensive package for analysis of RNAseq data
library(ShortRead) #working with short sequences
library(matrixStats) #stats and calculations
library(ggplot2) #great package for publication quality graphs
library(org.Mm.eg.db) #our organism-specific database package that we'll use for annotation
library(AnnotationDbi) #
# Study design --------------------------------------------
#In this section, you will layout the design of your experiment using a text file
#begin by reading in a text file where columns contain metadata and rows represent samples
targets <- read.delim("Beiting_studyDesign.txt", row.names=NULL)
#capture information about treatment groups from this file
groups <- paste(targets$genotype, targets$treatment, sep=".")
#turn this variable into a 'factor'
groups <- factor(groups)
#create some more human-readable labels for your samples using the info in your studyDesign file
sampleLabels <- paste(targets$genotype, targets$treatment, targets$rep, sep=".")
#set-up your experimental design
design <- model.matrix(~0+groups)
colnames(design) <- levels(groups)
design
# QC metrics for fastq ------------------------------------------
# #you can check read quality using shortRead package
# #but I usually find it is better to do this on the sequencer or Illumina's BaseSpace website
# myFastq <- targets$fastq
# #collecting statistics over the files
# qaSummary <- qa("B6-WT-untreat-rep2_S2_mergedLanes_read1.fastq", type="fastq")
# #create and view a report
# browseURL(report(qaSummary))
# Build Index from genome fasta --------------------------------
# expect this to take about 20 min on 8G RAM for mouse or genome
#you must have already downloaded the fasta file for your genome of interest and have it in the working directory
#this only needs to be done once, then index can be reused for future alignments
load("DGEList") #once loaded, take a look at this contents of this object
#retrieve all your gene/transcript identifiers from this DGEList object
myEnsemblIDs <- DGEList$genes$GeneID
#this next bit is not essential, but it's useful to graph your data before and after Log2 transformation
counts <- DGEList$counts
counts.Log2 <- log2(counts + 0.5)
countsSD <- transform(counts, SD=rowSds(counts, na.rm=TRUE), AVG=rowMeans(counts), MED=rowMedians(counts))
countsSD.Log2 <- transform(counts.Log2, SD=rowSds(counts.Log2, na.rm=TRUE), AVG=rowMeans(counts.Log2), MED=rowMedians(counts.Log2))
#now graph this data.
ggplot(countsSD, aes(x=SD, y=MED)) +
geom_point(shape=1) +
geom_point(size=4)
#the graph shows the non-Log2 data (median vs StdDev for each row)
#notice how the highly expressed genes have highest standard deviation.
#why might this be problem?
#now graph the Log2 data, to see how this basic transformation changes the structure of your data
ggplot(countsSD.Log2, aes(x=SD, y=MED)) +
geom_point(shape=1) +
geom_point(size=4)
#notice that the lowest expressed genes now have the highest StdDev
ggplot(countsSD.Log2, aes(x=SD, y=MED)) +
geom_point(shape=1) +
geom_point(size=4)
#notice that the lowest expressed genes now have the highest StdDev
# Normalize using mean-variance relationship ---------------
normData.unfiltered <- voom(DGEList, design, plot=TRUE)
exprs.unfiltered <- normData.unfiltered$E
exprs.matrix.unfiltered <- as.matrix(exprs.unfiltered)
head(exprs.matrix.unfiltered)
#Although RPKM are commonly used, not really necessary since you don't care to compare two different genes within a sample
rpkm.unfiltered <- log2(rpkm.unfiltered + 0.5)
#Only keep in the analysis those genes which had >10 reads per million mapped reads in at least two samples
DGEList.filtered <- DGEList[filter.test,]
rpkm.filtered <- rpkm(DGEList.filtered, DGEList.filtered$genes$Length) #if you prefer, can use 'cpm' instead of 'rpkm' here
#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative)
rpkm.unfiltered <- rpkm(DGEList, DGEList$genes$Length)
normData.filtered <- voom(DGEList.filtered, design, plot=TRUE)
exprs <- normData.filtered$E
exprs.matrix.filtered <- as.matrix(exprs)
#if you need RPKM for your unfiltered, they can generated as follows
# Annotating your data -----------------
# Filtering your dataset ----------------
#If we want to know what kinds of fields we could potentially use as keys to query the database, use the 'keytypes' command
dim(exprs.matrix.unfiltered)
filter.test <- rowSums(cpm(DGEList) > 10) >= 2
dim(DGEList.filtered)
rpkm.filtered <- log2(rpkm.filtered + 1)
myAnnot.unfiltered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.unfiltered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
keytypes(org.Mm.eg.db)
head(exprs.matrix.filtered)
columns(org.Mm.eg.db)
#transform you identifiers to entrezIDs
myAnnot.filtered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.filtered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
resultTable.unfiltered <- merge(myAnnot.unfiltered, exprs.matrix.unfiltered, by.x="ENSEMBL", by.y=0)
#If we want to know what kinds of data are retriveable via the 'select' command, look at the columns of the annotation database
resultTable.filtered <- merge(myAnnot.filtered, exprs.matrix.filtered, by.x="ENSEMBL", by.y=0)
#Use Voom again to normalize this filtered dataset
head(resultTable.unfiltered)
#add more appropriate sample names as column headers
colnames(resultTable.unfiltered) <- c("Ensembl", "entrez", "name", "symbol", sampleLabels)
colnames(resultTable.filtered) <- c("Ensembl", "entrez", "name", "symbol", sampleLabels)
#now write these annotated datasets out
write.table(resultTable.unfiltered, "normalizedUnfiltered.txt", sep="\t", quote=FALSE)
myAnnot.unfiltered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.unfiltered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
myAnnot.filtered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.filtered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
myAnnot.filtered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.filtered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
normData.filtered <- voom(DGEList.filtered, design, plot=TRUE)
filter.test <- rowSums(cpm(DGEList) > 10) >= 2
DGEList.filtered <- DGEList[filter.test,]
dim(DGEList.filtered)
rpkm.filtered <- rpkm(DGEList.filtered, DGEList.filtered$genes$Length) #if you prefer, can use 'cpm' instead of 'rpkm' here
rpkm.filtered <- log2(rpkm.filtered + 1)
dim(exprs.matrix.unfiltered)
#Use Voom again to normalize this filtered dataset
normData.filtered <- voom(DGEList.filtered, design, plot=TRUE)
exprs <- normData.filtered$E
exprs.matrix.filtered <- as.matrix(exprs)
head(exprs.matrix.filtered)
# Annotating your data -----------------
#If we want to know what kinds of data are retriveable via the 'select' command, look at the columns of the annotation database
columns(org.Mm.eg.db)
#If we want to know what kinds of fields we could potentially use as keys to query the database, use the 'keytypes' command
keytypes(org.Mm.eg.db)
#transform you identifiers to entrezIDs
myAnnot.unfiltered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.unfiltered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
myAnnot.filtered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.filtered), keytype="ENSEMBL", columns=c("ENTREZID", "GENENAME", "SYMBOL"))
resultTable.unfiltered <- merge(myAnnot.unfiltered, exprs.matrix.unfiltered, by.x="ENSEMBL", by.y=0)
resultTable.filtered <- merge(myAnnot.filtered, exprs.matrix.filtered, by.x="ENSEMBL", by.y=0)
head(resultTable.unfiltered)
#add more appropriate sample names as column headers
colnames(resultTable.unfiltered) <- c("Ensembl", "entrez", "name", "symbol", sampleLabels)
colnames(resultTable.filtered) <- c("Ensembl", "entrez", "name", "symbol", sampleLabels)
#now write these annotated datasets out
write.table(resultTable.unfiltered, "normalizedUnfiltered.txt", sep="\t", quote=FALSE)
write.table(resultTable.filtered, "normalizedFiltered.txt", sep="\t", quote=FALSE)
head(resultTable.filtered)
#congrats! You now have normalized and annotated RNAseq data
# Introduction to this script -----------
#goal of this script is to using multivariate statisical approaches to explore the structure of your data
#begin by taking a look at the text expression matrix you created at the end of the last class
head(exprs.matrix.unfiltered)
# Load packages -----
library(ggplot2)
library(reshape2)
# hierarchical clustering ---------------
#hierarchical clustering can only work on a data matrix, not a data frame
#try using filtered and unfiltered data...how does this change the results
distance <- dist(t(exprs.matrix.filtered), method="maximum") #other dist methods are "maximum", "manhattan", "canberra", "binary" or "minkowski"
clusters <- hclust(distance, method = "average") #other methods are ward.D, ward.D2, single, complete, average
plot(clusters, label = sampleLabels, hang = -1)
# Pricipal component analysis (PCA) -------------
pca.res <- prcomp(t(exprs.matrix.filtered), scale.=F, retx=T)
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
head(pca.res$rotation) #$rotation shows you how much each GENE influenced each PC (callled 'eigenvalues', or loadings)
head(pca.res$x) #$x shows you how much each SAMPLE influenced each PC (called 'scores')
plot(pca.res, las=1)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
# visualize your PCA result ------------------
#lets first plot any two PCs against each other
#turn your scores for each gene into a data frame
data.frame <- as.data.frame(pca.res$x)
ggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(groups))) +
geom_point(size=5) +
theme(legend.position="right")
#create a 'small multiples' chart to look at impact of each variable on each pricipal component
melted <- cbind(groups, melt(pca.res$x[,1:4]))
#look at your 'melted' data
ggplot(melted) +
geom_bar(aes(x=Var1, y=value, fill=groups), stat="identity") +
facet_wrap(~Var2)
library(ggplot2) #graphing package that employs a 'grammar of graphics' approach
library(reshape2) #data manipulation package
library(dplyr) #data manipulation package
library(ggvis) #for making interactive (dynamic) graphs in R, also follows the grammar of graphics philosophy
library(Rmisc) #for some basic statistics on our dataframe
# Data -------
#for this part of the class you'll be using your normalized filtered data
#make sure you have this object already in your work environment, or read a data file in now
#this file MUST be a dataframe, NOT a data matrix
head(resultTable.filtered)
colnames(resultTable.filtered)
# using dplyr 'mutate' function to add new columns based on existing data -------
# we'll use the dplyr 'mutate' command to make new columns based on existing ones (think Excel formula)
myData <- mutate(resultTable.filtered,
B6.untreated.AVG = (B6.untreated.1 + B6.untreated.2)/2,
Ripk3.untreated.AVG = (Ripk3.untreated.1 + Ripk3.untreated.2)/2,
Ripk3_Casp8.untreated.AVG = (Ripk3_Casp8.untreated.1 + Ripk3_Casp8.untreated.2)/2,
B6.LPS_6hr.AVG = (B6.LPS_6hr.1 + B6.LPS_6hr.2)/2,
Ripk3.LPS_6hr.AVG = (Ripk3.LPS_6hr.1 + Ripk3.LPS_6hr.2)/2,
Ripk3_Casp8.LPS_6hr.AVG = (Ripk3_Casp8.LPS_6hr.1 + Ripk3_Casp8.LPS_6hr.2)/2,
#now make columns comparing each of the averages above that you're interested in
LogFC.Ripk3.untreated_vs_B6.untreated = (Ripk3.untreated.AVG - B6.untreated.AVG),
LogFC.Ripk3_Casp8.untreated_vs_B6.untreated = (Ripk3_Casp8.untreated.AVG - B6.untreated.AVG),
LogFC.Ripk3_Casp8.untreated_vs_Ripk3.untreated = (Ripk3_Casp8.untreated.AVG - Ripk3.untreated.AVG),
LogFC.B6.LPS_6hr_vs_B6.untreated = (B6.LPS_6hr.AVG - B6.untreated.AVG),
LogFC.Ripk3.LPS_6hr_vs_B6.LPS_6hr = (Ripk3.LPS_6hr.AVG - B6.LPS_6hr.AVG),
LogFC.Ripk3_Casp8.LPS_6hr_vs_B6.LPS_6hr = (Ripk3_Casp8.LPS_6hr.AVG - B6.LPS_6hr.AVG))
#why is this type of approach to managing a spreadsheet useful?
#now look at this modified data table
head(myData)
# using dplyr 'arrange' and 'select' to sort your data table based on any variable -----
#use dplyr "arrange" and "select" functions to sort by LogFC column of interest (arrange)
#and then display only the columns of interest (select) to see the most differentially expressed genes
myData.sort <- myData %>%
arrange(desc(LogFC.B6.LPS_6hr_vs_B6.untreated)) %>%
select(symbol, LogFC.B6.LPS_6hr_vs_B6.untreated)
head(myData.sort)
# use dplyr "filter" and "select" functions to pick out genes of interest  ----
#ways to tweek the 'select' function
#use : between two column names to select all columns between
#use 'contains', 'starts_with' or 'ends_with' to modify how you select
#can refer to columns using exact name or numerical indicator
#use boolean operators such as '&' (and), '|' (or), '==' (equal to), '!' (not)
myData.filter <- myData %>%
filter(symbol=="Il1a" | symbol=="Cxcl10") %>%
select(symbol, B6.untreated.AVG, Ripk3.untreated.AVG, Ripk3_Casp8.untreated.AVG,
B6.LPS_6hr.AVG, Ripk3.LPS_6hr.AVG, Ripk3_Casp8.LPS_6hr.AVG)
head(myData.filter)
# make scatter plot -----
ggplot(myData, aes(x=B6.LPS_6hr.AVG, y=Ripk3_Casp8.LPS_6hr.AVG)) +
geom_point(shape=1) +
geom_point(size=4)
# make interactive scatter plot ----
tooltip <- function(data, ...) {
paste0("<b>","Symbol: ", data$symbol, "</b><br>",
"B6.LPS_6hr.AVG: ", data$B6.LPS_6hr.AVG, "<br>",
"Ripk3_Casp8.LPS_6hr.AVG: ", data$Ripk3_Casp8.LPS_6hr.AVG)
}
#plot the interactive graphic
myData %>%
ggvis(x= ~B6.LPS_6hr.AVG, y= ~Ripk3_Casp8.LPS_6hr.AVG, key := ~symbol) %>%
#layer_points(fill = ~LogFC.Ripk3_Casp8.LPS_6hr_vs_B6.LPS_6hr) %>%
add_tooltip(tooltip)
# with the data in its current form, you are very limited in the ways you can plot the data
# to remedy this, you must take this 'messy' data and make it 'tidy'
# see reading assignment today to learn more about how this works and see several examples
# What makes data tidy (according to Hadley Wickham)?
#1. Each variable forms a column
#2. Each ovservation forms a row
#3. Each type of observational unit forms a table
#*Messy data is anything that doesn't meet these three rules
library(reshape2)
myTidyData.all <- melt(resultTable.filtered)
head(myTidyData.all)
# make bar graph of select genes ----
#first pick some genes
myTidyData.filter <- myTidyData.all %>%
filter(symbol=="Il1a")
myTidyData.filter
#now graph
ggplot(myTidyData.filter, aes(y=symbol)) +
geom_bar(aes(x=variable, y=value), stat="identity") +
theme(axis.text.x=element_text(angle=-45))
#how would you improve or modify this graph?
# repeat bar graph, but this time with stats ----
#use your tidy dataset to calculate averages and standard deviations for each group
#first change column titles to reflect groups, not sample names
colnames(resultTable.filtered) <- c("Ensembl", "entrez", "name", "symbol", paste(targets$genotype, targets$treatment, sep = "."))
head(resultTable.filtered)
#again, make this data tidy
myTidyData2 <- melt(resultTable.filtered)
head(myTidyData2)
#calculate some stats based on the groups (NOT WORKING FROM HERE DOWN)
library(Rmisc)
dataSummary <- summarySE(myTidyData2, measurevar="value", groupvars=c("symbol","variable"))
head(dataSummary)
dataSummary.filter <- dataSummary %>%
filter(symbol=="Il1a")
dataSummary.filter
ggplot(dataSummary.filter, aes(x=variable, y=value, colour=symbol)) +
geom_errorbar(aes(ymin=value-sd, ymax=value+sd), width=.1) +
geom_line() +
geom_point()
# OPTIONAL: using grep to find match regular expressions ------
# Introduction to this script -----------
#the goal of this script is to identify differentially expressed genes (DEG)
#you should already know what pairwise comparisons are most important to you
#I prefer to use a table of data with a non-redundant set of gene identifiers as input for this script
#this keeps my heatmaps and lists of DEGS as simple of as possible
#if you have no biological replicates, you will NOT be able to leverage statistical tools to identify DE genes
#Instead, you will ONLY rely on fold changes, and can use the dplyr 'verbs' we discussed in the last class to identify genes based on fold changes
# Load packages -----
library(WGCNA) #an excellent package for network analysis, but in this script we will only use it for one function
library(limma) #powerful package for differential gene expression using linear modeling
# additional filtering based on annotation ----
#our initial filtering of RNAseq data was based on solely cpm, which only removes relatively lowly expressed genes
#now that you have annotation info, you can further filter to reduce to single line of data per gene symbol
#first, check out how many unqiue genes are represented in your data
head(resultTable.filtered)
dim(resultTable.filtered)
uniqueSymbols <- unique(resultTable.filtered$symbol)
#use collapseRows function from WGCNA package to collapse your dataset
#capture your rownames (unique) and the non-unique identifier that you'd like to collapse (in this case, gene symbols)
myIDs <- rownames(resultTable.filtered)
#retrieve your gene symbols from your data
mySymbols <- resultTable.filtered[,4]
#remove all annotation columns so you're left with only numeric data
resultTable <- resultTable.filtered[,-1:-4]
head(resultTable)
myCollapsed <- collapseRows(resultTable, mySymbols, myIDs, method = "MaxMean")
myCollapsed.data <- myCollapsed$datETcollapsed
dim(myCollapsed.data)
tail(myCollapsed.data)
fit <- lmFit(myCollapsed.data, design)
# set up a contrast matrix based on the pairwise comparisons of interest ------
#impact of LPS on WT macs
contrast.matrix.LPSwt <- makeContrasts(LPSwt = B6.LPS_6hr - B6.untreated, levels=design)
#impact of Ripk3 ko and Ripk3/Casp8 double ko on gene expression in naive mice
contrast.matrix.baseline <- makeContrasts(Ripk2.vs.wt = Ripk3.untreated - B6.untreated,
Ripk3Casp8.vs.wt = Ripk3_Casp8.untreated - B6.untreated,
Ripk3Casp8.vs.Ripk3 = Ripk3_Casp8.untreated - Ripk3.untreated,
levels=design)
#finally, and probably the most novel, the impact of Ripk3 and double Ko on LPS-induced gene expression
contrast.matrix.LPSko <- makeContrasts(Ripk2.vs.wt = Ripk3.LPS_6hr - B6.LPS_6hr,
Ripk3Casp8.vs.wt = Ripk3_Casp8.LPS_6hr - B6.LPS_6hr,
Ripk3Casp8.vs.Ripk3 = Ripk3_Casp8.LPS_6hr - Ripk3.LPS_6hr,
levels=design)
# extract the linear model fit for the contrast matrix that you just defined above -----
fits.LPSwt <- contrasts.fit(fit, contrast.matrix.LPSwt)
fits.baseline <- contrasts.fit(fit, contrast.matrix.baseline)
fits.LPSko <- contrasts.fit(fit, contrast.matrix.LPSko)
#get bayesian stats for your linear model fit
ebFit.LPSwt <- eBayes(fits.LPSwt)
ebFit.baseline <- eBayes(fits.baseline)
ebFit.LPSko <- eBayes(fits.LPSko)
#stats <- write.fit(ebFit)
# use topTable function to see the differentially expressed genes -----
myTopHits.LPSwt <- topTable(ebFit.LPSwt, adjust ="BH", coef=1, number=10, sort.by="logFC")
myTopHits.baseline <- topTable(ebFit.baseline, adjust ="BH", coef=3, number=10, sort.by="logFC")
myTopHits.LPSko <- topTable(ebFit.LPSko, adjust ="BH", coef=3, number=10, sort.by="logFC")
# use decideTests to pull out the DEGs and make Venn Diagram ----
results.LPSwt <- decideTests(ebFit.LPSwt, method="global", adjust.method="BH", p.value=0.01, lfc=2)
results.baseline <- decideTests(ebFit.baseline, method="global", adjust.method="BH", p.value=0.05, lfc=1)
results.LPSko <- decideTests(ebFit.LPSko, method="global", adjust.method="BH", p.value=0.05, lfc=0.58)
# take a look at what the results of decideTests looks like
results.LPSwt
summary(results.LPSko)
vennDiagram(results.LPSwt, include="both")
vennDiagram(results.baseline, include="both")
vennDiagram(results.LPSko, include="both")
# retrieve expression data for your DEGs ----
dim(myCollapsed.data)
diffData.LPSwt <- myCollapsed.data[results.LPSwt[,1] !=0,]
diffData.baseline <- myCollapsed.data[results.baseline[,1] !=0 | results.baseline[,2] !=0 | results.baseline[,3] !=0,]
diffData.LPSko <- myCollapsed.data[results.LPSko[,1] !=0 | results.LPSko[,2] !=0 | results.LPSko[,3] !=0,]
head(diffData.LPSwt)
dim(diffData.LPSwt)
#write your DEGs to a file
write.table(diffData.LPSwt,"DiffGenes_LPSwt.xls", sep="\t", quote=FALSE)
write.table(diffData.baseline,"DiffGenes_baseline.xls", sep="\t", quote=FALSE)
write.table(diffData.LPSko,"DiffGenes_LPSko.xls", sep="\t", quote=FALSE)
##look at your stats for these DEGs out to a file
#write.fit(fits.LPSwt, results.LPSwt, "myfit.txt", sep="\t")
#myStats <- read.delim("myFit.txt", header=T, sep="\t")
#diffStats <- myStats[results[,1] !=0 | results[,2] !=0 | results[,3] !=0,]
#dim(diffStats)
##if you want DEGs with expression and stats in one file
#write.table(cbind(diffData, diffStats), "myFavs.xls", sep="\t", quote=FALSE)
# OPTIONAL: removal of unwanted variation (RUV)...NOT WORKING YET ----
heatmap.2(diffData.LPSwt.AVG, Rowv=as.dendrogram(hr.LPSwt), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSwt,
cexRow=1, cexCol=1, margins=c(8,20))
library(gplots)
library(RColorBrewer)
library(limma)
# set up a color pallette ----
#Some useful examples: colorpanel(40, "darkblue", "yellow", "white"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,"Blues")[-1]).
myheatcol <- greenred(75)
# generate a heatmap of DEGs ----
#begin by clustering the genes (rows) in each set of differentially expressed genes
hr.LPSwt <- hclust(as.dist(1-cor(t(diffData.LPSwt), method="pearson")), method="complete") #cluster rows by pearson correlation
hr.baseline <- hclust(as.dist(1-cor(t(diffData.baseline), method="pearson")), method="complete") #cluster rows by pearson correlation
hr.LPSko <- hclust(as.dist(1-cor(t(diffData.LPSko), method="pearson")), method="complete") #cluster rows by pearson correlation
#now cluster your samples (columns)
#we may not acutally use this clustering, but it's good to have just in case
hc.LPSwt <- hclust(as.dist(1-cor(diffData.LPSwt, method="spearman")), method="complete") #cluster columns by spearman correlation
hc.baseline <- hclust(as.dist(1-cor(diffData.baseline, method="spearman")), method="complete") #cluster columns by spearman correlation
hc.LPSko <- hclust(as.dist(1-cor(diffData.LPSko, method="spearman")), method="complete") #cluster columns by spearman correlation
# Cut the resulting tree and create color vector for clusters.
#Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters
#we'll look at these clusters in more detail later
mycl.LPSwt <- cutree(hr.LPSwt, k=2)
mycl.baseline <- cutree(hr.baseline, k=3)
mycl.LPSko <- cutree(hr.LPSko, k=15)
#now assign a color to each cluster (makes it easy to identify and manipulate)
mycolhc.LPSwt <- rainbow(length(unique(mycl.LPSwt)), start=0.1, end=0.9)
mycolhc.LPSwt <- mycolhc.LPSwt[as.vector(mycl.LPSwt)]
mycolhc.baseline <- rainbow(length(unique(mycl.baseline)), start=0.1, end=0.9)
mycolhc.baseline <- mycolhc.baseline[as.vector(mycl.baseline)]
mycolhc.LPSko <- rainbow(length(unique(mycl.LPSko)), start=0.1, end=0.9)
mycolhc.LPSko <- mycolhc.LPSko[as.vector(mycl.LPSko)]
#plot the hclust results as a heatmap
# first, a heatmap of genes regulated by LPS in a WT background
heatmap.2(diffData.LPSwt.AVG, Rowv=as.dendrogram(hr.LPSwt), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSwt,
cexRow=1, cexCol=1, margins=c(8,20))
# second, a heatmap of genes affected by Ripk3 or Casp8 deficiency in untreated cells (baseline)
heatmap.2(diffData.baseline.AVG, Rowv=as.dendrogram(hr.baseline), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.baseline,
cexRow=1, cexCol=1, margins=c(8,20))
# third, a heatmap of LPS regulated genes that are Casp8-dependent
heatmap.2(diffData.LPSko.AVG, Rowv=as.dendrogram(hr.LPSko), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSko,
cexRow=1, cexCol=1, margins=c(8,20))
# edit heatmap to simplify----
#notice that the heatmap includes ALL the columns from your dataset
#to simplify, average biological replicates
#then rerun the heatmap the script above using diffData.AVG as input instead of diffData
colnames(diffData.LPSwt) <- groups
colnames(diffData.baseline) <- groups
colnames(diffData.LPSko) <- groups
diffData.LPSwt.AVG <- avearrays(diffData.LPSwt)
diffData.baseline.AVG <- avearrays(diffData.baseline)
diffData.LPSko.AVG <- avearrays(diffData.LPSko)
##alternatively, decide exactly which columns you want to show, and modify the heatmap accordingly
#diffData.subset <- diffData.LPS[,c(1,2,4,6)]
##now repeat heatmap only on these selected columns
# pull out clusters of co-regulated genes ----
# view your color assignments for the different clusters
names(mycolhc.LPSko) <- names(mycl.LPSko)
barplot(rep(10, max(mycl.LPSko)),
col=unique(mycolhc.LPSko[hr.LPSko$labels[hr.LPSko$order]]),
horiz=T, names=unique(mycl.LPSko[hr.LPSko$order]))
#choose a cluster(s) of interest by selecting the corresponding number based on the previous graph
#first cluster to pick are the genes in KO cells that lose LPS-inducibility
heatmap.2(diffData.LPSwt.AVG, Rowv=as.dendrogram(hr.LPSwt), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSwt,
cexRow=1, cexCol=1, margins=c(8,20))
# second, a heatmap of genes affected by Ripk3 or Casp8 deficiency in untreated cells (baseline)
heatmap.2(diffData.baseline.AVG, Rowv=as.dendrogram(hr.baseline), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.baseline,
cexRow=1, cexCol=1, margins=c(8,20))
# third, a heatmap of LPS regulated genes that are Casp8-dependent
heatmap.2(diffData.LPSko.AVG, Rowv=as.dendrogram(hr.LPSko), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSko,
cexRow=1, cexCol=1, margins=c(8,20))
heatmap.2(diffData.LPSko.AVG, Rowv=as.dendrogram(hr.LPSko), Colv=NA,
col=myheatcol, scale="row", labRow=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSko,
cexRow=1, cexCol=1, margins=c(8,20), key=F)
heatmap.2(diffData.LPSko.AVG, Rowv=as.dendrogram(hr.LPSko), Colv=NA,
col=myheatcol, scale="row", labRow=NA, labCol=NA,
density.info="none", trace="none", RowSideColors=mycolhc.LPSko,
cexRow=1, cexCol=1, margins=c(8,20), key=F)
