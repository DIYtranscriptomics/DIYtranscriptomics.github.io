{
    "contents" : "#this is where you'll build your analysis script throughout the workshop\n##############################################################################################################################\n#Step1_preprocessRNAseq\n#This script carries out the steps involved in analysis of RNAseq data.  \n#depending on your data and interests, different parts of this script may not apply to you\n##############################################################################################################################\n#begin by loading the packages required for RNAseq data\nlibrary(Rsubread)\nlibrary(limma)\nlibrary(edgeR)\nlibrary(ShortRead)\noptions(digits=2)\n#library(Biostrings)\n\n#read in your study design file\ntargets <- readTargets(\"Igor_Ripk3_BMMC_studyDesign_RNAseq.txt\", row.names=NULL)\ntargets\ntargets.mod <- targets[1:12,]\ngroups <- factor(paste(targets.mod$genotype, targets.mod$treatment, sep=\".\"))\n#create some more human-readable labels for your samples using the info in this file\nsampleLabels <- paste(targets.mod$genotype, targets.mod$treatment, targets.mod$rep, sep=\".\")\n\n#set-up your experimental design\ndesign <- model.matrix(~0+groups)\ncolnames(design) <- levels(groups)\ndesign\n\n# ##############################################################################################################################\n# #you can check read quality using shortRead package\n# #but I usually find it is better to do this on the sequencer or Illumina's BaseSpace website\n# ##############################################################################################################################\n# myFastq <- targets$fastq\n# #collecting statistics over the files\n# qaSummary <- qa(\"B6-WT-untreat-rep2_S2_mergedLanes_read1.fastq\", type=\"fastq\")\n# #create and view a report\n# browseURL(report(qaSummary))\n\n##############################################################################################################################\n#build index from your reference genome (expect this to take about 20 min on 8G RAM for mouse genome)\n#you must have already downloaded the fasta file for your genome of interest and have it in the working directory\n#this only needs to be done once, then index can be reused for future alignments\n##############################################################################################################################\nbuildindex(basename=\"mouse\",reference=\"Mus_musculus.GRCm38.dna.primary_assembly.fa\")\n\n##############################################################################################################################\n#align your reads (in the fastq files) to your indexed reference genome that you created above\n#expect this to take about 45min for a single fastq file containing 25 million reads\n#the output from this is a .bam file for each of your original fastq files\n##############################################################################################################################\nreads1 <- targets$fastq[9]\nreads2 <- targets$fastq[21] \nalign(index=\"mouse\", readfile1=reads1, readfile2=reads2, input_format=\"gzFASTQ\",output_format=\"BAM\",\n      output_file=\"alignmentResultsPE_sample9.BAM\", tieBreakHamming=TRUE,unique=TRUE,indels=5, nthreads=8)\n\n##############################################################################################################################\n#use the 'featureCounts' function to summarize read counts to genomic features (exons, genes, etc)\n#will take about 1-2min per .bam file.\n#for total transcriptome data summarized to mouse/human .gtf, expect about 50-60% of reads summarize to genes (rest is non-coding)\n##############################################################################################################################\n#read in text file with bam file names\nMyBAM <- read.delim(\"BAMfiles_names.txt\", header=T)\nMyBAM <- as.character(MyBAM[,1])\n#summarize aligned reads to genomic features (i.e. exons)\nfc <- featureCounts(files=MyBAM, annot.ext=\"Mus_musculus.GRCm38.79.gtf\", isGTFAnnotationFile=TRUE, GTF.featureType = \"exon\",\n                    GTF.attrType=\"gene_id\", useMetaFeatures=TRUE, isPairedEnd=TRUE, requireBothEndsMapped=TRUE, strandSpecific=2, nthreads=8)\n#use the 'DGEList' function from EdgeR to make a 'digital gene expression list' object\nDGEList <- DGEList(counts=fc$counts, genes=fc$annotation)\nload(\"DGElist\")\n#retrieve all your gene/transcript identifiers from this DGEList object\nmyEnsemblIDs <- DGEList$genes$GeneID\n\n##############################################################################################################################\n#Normalize unfiltered data using 'voom' function in Limma package\n#This will normalize based on the mean-variance relationship\n#will also generate the log2 of counts per million based on the size of each library (also a form of normalization)\n##############################################################################################################################\nnormData.unfiltered <- voom(DGEList, design, plot=TRUE)\nexprs.unfiltered <- normData.unfiltered$E\nexprs.matrix.unfiltered <- as.matrix(exprs.unfiltered)\n#note that because you're now working with Log2 CPM, much of your data will be negative number (log2 of number smaller than 1 is negative) \nhead(exprs.matrix.unfiltered)\n\n#if you need RPKM for your unfiltered, they can generated as follows\n#Although RPKM are commonly used, not really necessary since you don't care to compare two different genes within a sample\nrpkm.unfiltered <- rpkm(DGEList, DGEList$genes$Length)\ntail(rpkm)\n\n##############################################################################################################################\n#Filtering your dataset\n#Only keep in the analysis those genes which had >10 reads per million mapped reads in at least two libraries.\n#Need to remove duplicate gene symbols\n##############################################################################################################################\ncpm.matrix.filtered <- rowSums(cpm(DGEList) > 10) >= 2\nDGEList.filtered <- DGEList[cpm.matrix.filtered,]\ndim(DGEList.filtered)\nrpkm.filtered <- rpkm(DGEList.filtered, DGEList.filtered$genes$Length) #if you prefer, can use 'cpm' instead of 'rpkm' here\n# \"+1\" because log2 of negative and 0 will give you infinity and you want to avoid that\nrpkm.filtered <- log2(rpkm.filtered + 1)\n\n#Use Voom again to normalize this filtered dataset\nnormData <- voom(DGEList.filtered, design, plot=TRUE)\nexprs <- normData$E\nexprs.matrix.filtered <- as.matrix(exprs)\nhead(exprs.matrix.filtered)\n\n##############################################################################################################################\n#annotate your normalized data using the organism-specific database package\n##############################################################################################################################\nlibrary(org.Mm.eg.db)\nlibrary(AnnotationDbi)\n#ls(\"package:org.Mm.eg.db\")\n#If we want to know what kinds of data are retriveable via the 'select' command, look at the columns of the annotation database\ncolumns(org.Mm.eg.db)\n#If we want to know what kinds of fields we could potentially use as keys to query the database, use the 'keytypes' command\nkeytypes(org.Mm.eg.db)\n#transform your identifiers to entrezIDs\nmyAnnot.unfiltered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.unfiltered), keytype=\"ENSEMBL\", columns=c(\"ENTREZID\", \"REFSEQ\", \"UNIGENE\", \"GENENAME\", \"SYMBOL\"))\nmyAnnot.filtered <- AnnotationDbi::select(org.Mm.eg.db, keys=rownames(exprs.matrix.filtered), keytype=\"ENSEMBL\", columns=c(\"ENTREZID\", \"REFSEQ\", \"UNIGENE\", \"GENENAME\", \"SYMBOL\"))\nresultTable.unfiltered <- merge(myAnnot.unfiltered, exprs.matrix.unfiltered, by.x=\"ENSEMBL\", by.y=0)\nresultTable.filtered <- merge(myAnnot.filtered, exprs.matrix.filtered, by.x=\"ENSEMBL\", by.y=0)\nhead(resultTable.unfiltered)\n#add more appropriate sample names as column headers\ncolnames(resultTable.unfiltered) <- c(\"Ensembl\", \"Entrez\", \"Refseq\", \"Unigene\", \"Name\", \"Symbol\", sampleLabels)\ncolnames(resultTable.filtered) <- c(\"Ensembl\", \"Entrez\", \"Refseq\", \"Unigene\", \"Name\", \"Symbol\", sampleLabels)\n#now write these annotated datasets out\nwrite.table(resultTable.unfiltered, \"normalizedUnfilteredRNAseq.txt\", sep=\"\\t\", quote=FALSE)\nwrite.table(resultTable.filtered, \"normalizedFilteredRNAseq.txt\", sep=\"\\t\", quote=FALSE)\nhead(resultTable.unfiltered)\nhead(resultTable.filtered)\n\n#end of Step1_preprocessRNAseq\n\n###########################################################\n#Start of Collapse Function\n#I prefer to use a table of data with a non-redundant set of gene identifiers as input for this script\n#this keeps my heatmaps and lists of DEGS as simple of as possible\n#if you are coming to this script with array data, you've already reduced your list in this way\n#RNAseq data is a bit more complicated (many transcripts, but the same gene), \n#but you achieve the same level of reduction by filtering based on annotation data\n#################################################################\n\n#additional filtering based on annotation\n#if you have array data, you can skip this section\n#################################################################\n\n#our initial filtering of RNAseq data was based on solely cpm, which only removes relatively lowly expressed genes\n#now that you have annotation info, you can further filter to reduce to single line of data per gene symbo using one of two options\n#first, check out how many unqiue genes are represented in your data\ndupFiltered <- unique(resultTable.filtered$Symbol)\n#use collapseRows function from WGCNA package to collapse your dataset\nlibrary(WGCNA)\n#pull your rownames and unique identifiers\nmyIDs <- rownames(resultTable.filtered)\n#retrieve your gene symbols from your data\nmySymbols <- resultTable.filtered[,6]\n#remove all annotation columns so you're left with only numeric data\nresultTable <- resultTable.filtered[,-1:-6]\nmyCollapsed <- collapseRows(resultTable, mySymbols, myIDs, method = \"MaxMean\")\nmyCollapsed <- myCollapsed$datETcollapsed\nwrite.table(myCollapsed, \"Collapsed.txt\", sep=\"\\t\", quote=FALSE)\n#now that the matrix is collapsed to give non-redudant list of genes,\n#you could set the symbols to be the row names and move on\n\n#for GSEA tab delimited file. Clean data (remove unnecessary columns and make lower case upper case)\nmyCollapsedRNAseq <- read.delim(\"Collapsed.txt\", header=T, sep=\"\\t\")\nhead(myCollapsedRNAseq)\n#need to convert gene symbols to uppercase\nmySymbolsforGSEA <- toupper(row.names(myCollapsedRNAseq))\nhead(mySymbolsforGSEA)\n#need to add column back to data\nmyCollapsedRNAseq <- cbind(mySymbolsforGSEA, myCollapsedRNAseq)\nwrite.table(myCollapsedRNAseq, \"myCollapsedRNAseq.txt\", sep=\"\\t\", quote=FALSE)\n\n#to make grp file from other published arrays for GSEA and make lower case upper case)\nFontanaJunB <- read.delim(\"FontanaJunB.txt\", header=T, sep=\"\\t\")\nhead(FontanaJunB)\n#need to convert gene symbols to uppercase\nFontanaJunB <- toupper(FontanaJunB[,1])\ndim(FontanaJunB)\nhead(FontanaJunB)\nwrite.table(FontanaJunB, \"FontanaJunB.txt\", sep=\"\\t\", quote=FALSE)\n##############################################################################################\n\n#Step2_dataExploration\n#goal of this script is to using multivariate statisical approaches to explore the structure of your data\n#begin by taking a look at the text expression matrix you created at the end of the last class\n#head(exprs.matrix.filtered) # don't need this because I have myCollapsed data\n\n###############################################################################################\n# set up your experimental design by reading in a targets file that explains treatments, conditions, etc\n###############################################################################################\nlibrary(limma)\n#read in a tab-delimited \"targets\" file with the study design\ntargets <- readTargets(\"Igor_Ripk3_BMMC_studyDesign_RNAseq.txt\", sep=\"\\t\")\ntargets\nmyGroups <- factor(paste(targets$genotype, targets$treatment, sep=\".\"))\nmyGroups\ndesign <- model.matrix(~0+myGroups)\ncolnames(design) <- levels(myGroups)\ndesign\n\n\n###############################################################################################\n#carry out hierarchical clustering on filtered data\n###############################################################################################\n#make some sample labels \nsampleLabels <- paste(targets$genotype, targets$treatment, sep=\".\")\ndistance <- dist(t(exprs.matrix.filtered),method=\"maximum\")\nclusters <- hclust(distance, method = \"complete\") \n#plot cluster dendrogram\nplot(clusters, label = sampleLabels, hang = -1)\n\n\n###############################################################################################\n#Principal component analysis of the filtered data matrix T=transpose\n###############################################################################################\npca.res <- prcomp(t(exprs.matrix.filtered), scale.=F, retx=T)\nls(pca.res)\nsummary(pca.res) # Prints variance summary for all principal components.\nhead(pca.res$rotation) #$rotation shows you how much each GENE influenced each PC (callled 'eigenvalues', or loadings)\nhead(pca.res$x) #$x shows you how much each SAMPLE influenced each PC (called 'scores')\nplot(pca.res, las=1) #las sets labels horizontal\npc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues\npc.per<-round(pc.var/sum(pc.var)*100, 1) #percentage variance\npc.per\n\n#make some graphs to visualize your PCA result\nlibrary(ggplot2)\n#lets first plot any two PCs against each other\n#turn your scores for each gene into a data frame\ndata.frame <- as.data.frame(pca.res$x)\nggplot(data.frame, aes(x=PC1, y=PC2, colour=factor(myGroups))) +\n  geom_point(size=5) +\n  theme(legend.position=\"right\")\n\n#create a 'small multiples' chart to look at impact of each variable on each pricipal component\nlibrary(reshape2)\nmelted <- cbind(myGroups, melt(pca.res$x[,1:3]))\n#look at your 'melted' data\nggplot(melted) +\n  geom_bar(aes(x=Var1, y=value, fill=myGroups), stat=\"identity\") +\n  facet_wrap(~Var2)\n#if you have a batch effect can use combat function to take care of that\n\n###################################################################################################\n#########################################\n\n### Step3_dataWrangling\n\n#this script walks thorough some basic data wrangling for organizing expression data spreadsheets and ends with\n#how to create publication quality graphics from transcriptomic data generated (regardless of platform used)\n#to start this script you need a file with all your expression data and some non-redundant identifiers as row names (usually gene symbols)\n#you also need a study design file\n\n#for creating graphics, we'll use the ggplot2 and ggvis packages which employ a 'grammar of graphics' approach\n#load the packages\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggvis)\n\n#read in your data from a text file that contains genes symbols as rows, and samples as columns. \nmyCollapsedData <- read.delim(\"Collapsed.txt\", header=TRUE)\nhead(myCollapsedData)\n#subset data to get rid of column \"2\" = -2\n#myData <- myData[,-2]\n#make column 1 the row names of myData\n#row.names(myData) <- myData[,1]\n#myData <- myData[,-1]\n#head(myData)\n\n# [This is probably not necessary since myCollapsedData already has column headers, but for array data use this] column headers are a bit cumbersome, so we'll change these to something more human-readable\n#targets <- read.delim(\"Igor_Ripk3_BMMC_studyDesign_RNAseq.txt\", sep=\"\\t\", stringsAsFactors = FALSE)\n#sampleLabels <- as.character(paste(targets$cellType, targets$treatment, targets$phenotype, targets$rep, sep=\".\"))\n#colnames(myData) <- sampleLabels\n#head(myData)\ngeneSymbols <- row.names(myCollapsedData)\n#myCollapsedData.df <- as.data.frame(myCollapsedData)\n#head(myCollapsedData.df)\n\n#use the dplyr 'mutate' command to get averages and fold changes for all your replicates, dplyr only works on data frames and row names are not considered part of the table\nmyCollapsedData <- mutate(myCollapsedData,\n                      B6.untreated.AVG = (B6.untreated.1 + B6.untreated.2)/2,\n                      Ripk3.untreated.AVG = (Ripk3.untreated.1 + Ripk3.untreated.2)/2,\n                      Ripk3_Casp8.untreated.AVG = (Ripk3_Casp8.untreated.1 + Ripk3_Casp8.untreated.2)/2,\n                      B6.LPS_6hr.AVG = (B6.LPS_6hr.1 + B6.LPS_6hr.2)/2,\n                      Ripk3.LPS_6hr.AVG = (Ripk3.LPS_6hr.1 + Ripk3.LPS_6hr.2)/2,\n                      Ripk3_Casp8.LPS_6hr.AVG = (Ripk3_Casp8.LPS_6hr.1 + Ripk3_Casp8.LPS_6hr.2)/2,\n                      LogFC.Ripk3.LPS_6hr.vs.B6.LPS_6hr = (Ripk3.LPS_6hr.AVG - B6.LPS_6hr.AVG),\n                      LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr = (Ripk3_Casp8.LPS_6hr.AVG - Ripk3.LPS_6hr.AVG),\n                      LogFC.Ripk3_Casp8.LPS_6hr.vs.B6.LPS_6hr = (Ripk3_Casp8.LPS_6hr.AVG - B6.LPS_6hr.AVG),\n                      LogFC.Ripk3_Casp8.untreated.vs.Ripk3.untreated = (Ripk3_Casp8.untreated.AVG - Ripk3.untreated.AVG),\n                      LogFC.Ripk3.untreated.vs.B6.untreated = (Ripk3.untreated.AVG - B6.untreated.AVG),\n                      LogFC.Ripk3_Casp8.untreated.vs.B6.untreated = (Ripk3_Casp8.untreated.AVG - B6.untreated.AVG),\n                      geneSymbols=geneSymbols) # why do we have a column at the end with gene Symbols??\n\n#now look at this modified data table\nrow.names(myCollapsedData) <- geneSymbols\nhead(myCollapsedData)\ndim(myCollapsedData)\n#capture the symbols from the rownames and set to an object called 'symbols'\nsymbols <- rownames(myCollapsedData)\n#now get rid of rownames\nrownames(myCollapsedData) <- NULL\n#now edit your data to contain a first column with symbols\nmyCollapsedData <- cbind(symbols, myCollapsedData)\nhead(myCollapsedData)\n#now save this new data object to replace the old one\nsave(myCollapsedData, file=\"myCollapsedData\")\n\n\n#use dplyr \"arrange\" and \"select\" functions to sort by LogFC column of interest (arrange)\n#and then display only the columns of interest (select) to see the most differentially expressed genes\nmyCollapsedData.sort <- myCollapsedData %>%\n  arrange(desc(LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr)) %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr) \nhead(myCollapsedData.sort)\n\n#use dplyr \"filter\" and \"select\" functions to pick out genes of interest (filter)\n#ways to tweek the 'select' function\n#use : between two column names to select all columns between\n#use 'contains', 'starts_with' or 'ends_with' to modify how you select\n#can refer to columns using exact name or numerical indicator\nmyCollapsedData.filter <- myCollapsedData %>%\n  filter(geneSymbols==\"Irf1\" | geneSymbols==\"Junb\") %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr) \nhead(myCollapsedData.filter)\n\nmyCollapsedData.filter <- myCollapsedData %>%\n  filter(geneSymbols==\"Irf1\" | geneSymbols==\"Junb\") %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.B6.LPS_6hr, LogFC.Ripk3.LPS_6hr.vs.B6.LPS_6hr, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr ) \nhead(myCollapsedData.filter)\n\n#another example using grep to match patterns\nmyCollapsedData.filter <- myCollapsedData %>%\n  #filter(grepl('Ccl', geneSymbols)) %>%\n  filter(grepl('Il', geneSymbols)) %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr) \nhead(myCollapsedData.filter)\n\n#first reorder and clean up the data you want to graph\n#row.names(myCollapsedData.filter) <- myCollapsedData.filter[,1]\n#myCollapsedData.filter <- select(myCollapsedData.filter, -geneSymbols)\n#myCollapsedData.filter.transpose <- as.data.frame(t(myCollapsedData.filter))\n#cellType <- c(\"B1a\", \"B1b\", \"Mac\")\n#myCollapsedData.filter.transpose <- mutate(myData.filter.transpose, cellType, \n                                  phenotype=c(\"naive\", \"naive\",\"naive\"))\n#myCollapsedData.filter.transpose\n\n#another way to set up for graphing...don't filter before transposing\n#myCollapsedData.graph <- select(myCollapsedData,-geneSymbols)\n#head(myCollapsedData.graph)\n#myCollapsedData.graph.transpose <- as.data.frame(t(myCollapsedData.graph))\n#dim(myCollapsedData.graph.transpose)\n\n#plot a simple bar graph - y=column of interest, x= row of interest from filtered table\nggplot(myCollapsedData.filter, aes(y=LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr)) +\n  geom_bar(aes(x=geneSymbols, fill=LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr), stat=\"identity\") +\n  theme(axis.text.x=element_text(angle=-45))\n\n#create a basic scatterplot using ggplot\nggplot(myCollapsedData, aes(x=Ripk3.LPS_6hr.AVG, y=Ripk3_Casp8.LPS_6hr.AVG)) +\n  geom_point(shape=1) +\n  geom_point(size=4)\n\n# ##Volcano plots\n# ##Highlight genes that have an absolute fold change > 2 and a p-value < Bonferroni cut-off\n# gene_list$threshold = as.factor(abs(gene_list$logFC) > 2 & gene_list$P.Value < 0.05/no_of_genes)\n# \n# ##Construct the volcano plot\n# ggplot(data=myData, aes(x=logFC, y=-log10(P.Value), colour=threshold)) +\n#   geom_point(alpha=0.4, size=1.75) +\n#   opts(legend.position = \"none\") +\n#   xlim(c(-10, 10)) + ylim(c(0, 15)) +\n#   xlab(\"log2 fold change\") + ylab(\"-log10 p-value\")\n\n#define a tooltip that shows gene symbol and Log2 expression data when you mouse over each data point in the plot\ntooltip <- function(data, ...) {\n  paste0(\"<b>\",\"Symbol: \", data$geneSymbols, \"</b><br>\",\n         \"Ripk3.LPS_6hr.AVG: \", data$Ripk3.LPS_6hr.AVG, \"<br>\",\n         \"Ripk3_Casp8.LPS_6hr.AVG: \", data$Ripk3_Casp8.LPS_6hr.AVG)\n}\n\n#plot the interactive graphic\nmyCollapsedData %>% \n  ggvis(x= ~Ripk3.LPS_6hr.AVG, y= ~Ripk3_Casp8.LPS_6hr.AVG, key := ~geneSymbols) %>% \n  layer_points(fill = ~LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr) %>%\n  add_tooltip(tooltip)\n\n################################################################\n\n#Step 4\n\n#first part of this script is in Step 1 \n#the goal of this script is to identify differentially expressed genes (DEG) \n#you should already know what pairwise comparisons are most important to you\n\n#I prefer to use a table of data with a non-redundant set of gene identifiers as input for this script\n#this keeps my heatmaps and lists of DEGS as simple of as possible\n#if you are coming to this script with array data, you've already reduced your list in this way\n#RNAseq data is a bit more complicated (many transcripts, but the same gene), \n#but you achieve the same level of reduction by filtering based on annotation data\n#################################################################\n#additional filtering based on annotation\n#if you have array data, you can skip this section\n#################################################################\n#our initial filtering of RNAseq data was based on solely cpm, which only removes relatively lowly expressed genes\n#now that you have annotation info, you can further filter to reduce to single line of data per gene symbol\n#first, check out how many unqiue genes are represented in your data\ndupFiltered <- unique(resultTable.filtered$Symbol)\n#use collapseRows function from WGCNA package to collapse your dataset\nlibrary(WGCNA)\n#pull your rownames and unique identifiers\nmyIDs <- rownames(resultTable.filtered)\n#retrieve your gene symbols from your data\nmySymbols <- resultTable.filtered[,6]\n#remove all annotation columns so you're left with only numeric data because you need to calculate the mean\nresultTable <- resultTable.filtered[,-1:-6]\n# function(data table, the group that is redundant, unique identifier, method of collapsing)\nmyCollapsed <- collapseRows(resultTable, mySymbols, myIDs, method = \"MaxMean\")\nmyCollapsed <- myCollapsed$datETcollapsed\nwrite.table(myCollapsed, \"Collapsed.txt\", sep=\"\\t\", quote=FALSE)\n#now that the matrix is collapsed to give non-redudant list of genes,\n#you could set the symbols to be the row names and move on\n\n#################################################################################################################\n#if you have no biological replicates, you will not be able to leverage statistical tools to identify DE genes\n#Instead, you will ONLY rely on fold changes\n#if you DO have replicates, skip this section and proceed to the next part \n#################################################################################################################\n#use the dplyr 'filter' command to capture all the genes that are up/down regulated x-fold in n conditions\n#in this case, 'myData' is a dataframe that you generated with Log2 expression and annotation\n#myData.filter <- myData %>%\n  #filter((abs(Ecdysone.vs.PBS_18hr_gut) >= 1) | (abs(Ecdysone.vs.PBS_5hr_gut) >= 1)) %>%\n  #select(geneID, Ecdysone.vs.PBS_5hr_carcass, Ecdysone.vs.PBS_18hr_carcass, Ecdysone.vs.PBS_5hr_gut, Ecdysone.vs.PBS_18hr_gut)\n#head(myData.filter)\n\n\n###############################################################################################\n# use Limma to find differentially expressed genes between two or more conditions\n###############################################################################################\n# fit the linear model to your filtered expression data in matrix format only samples and rownames no AVG or FC\nlibrary(limma)\nrownames(myCollapsed)\ndim(myCollapsed)\nfit <- lmFit(myCollapsed, design)\n#feed in data from the differential gene expression of UT vs LPS\nrownames(diffDataUT.LPS)\nfitUTvLPS <- lmFit(diffDataUT.LPS, design)\n#add annotation into your linear model fit\n#don't really need to do this if you have RNAseq data\n#library(annotate)\n#fit$genes$Symbol <- getSYMBOL(probeList, \"lumiMouseAll.db\")\n#fit$genes$Entrez <- getEG(probeList, \"lumiMouseAll.db\")\n\n# set up a contrast matrix based on the pairwise comparisons of interest\ncontrast.matrix.LPS <- makeContrasts(R3C8.v.R3 = Ripk3_Casp8.LPS_6hr - Ripk3.LPS_6hr, \n                                     R3.v.B6 = Ripk3.LPS_6hr - B6.LPS_6hr, \n                                     R3C8.v.B6 = Ripk3_Casp8.LPS_6hr - B6.LPS_6hr, levels=design)\ncontrast.matrix.untreated <- makeContrasts(R3C8.v.R3.untreated = Ripk3_Casp8.untreated - Ripk3.untreated, \n                                           R3.v.B6.untreated = Ripk3.untreated - B6.untreated, R3C8.v.B6.untreated = Ripk3_Casp8.untreated - B6.untreated, levels=design)\n\n### set up a contrast matrix comparing UT and LPS\ncontrast.matrix.UT.LPS <- makeContrasts(B6UT.v.B6LPS = B6.LPS_6hr - B6.untreated, R3UT.v.R3LPS = Ripk3.LPS_6hr - Ripk3.untreated, R3C8UT.v.R3C8LPS = Ripk3_Casp8.LPS_6hr - Ripk3_Casp8.untreated, levels=design)\n\n# check each contrast matrix\ncontrast.matrix.LPS\ncontrast.matrix.untreated\ncontrast.matrix.UT.LPS\n\n# extract the linear model fit for the contrast matrix that you just defined above\nfitsLPS <- contrasts.fit(fit, contrast.matrix.LPS)\nfitsUntreated <- contrasts.fit(fit, contrast.matrix.untreated)\nfitsUT.LPS <- contrasts.fit(fit, contrast.matrix.UT.LPS)\n\n# Now do the same for the UT vs LPS Diff Expr Genes\nfits.of.LPS <- contrasts.fit(fitUTvLPS, contrast.matrix.LPS)\n\n#get bayesian stats for your linear model fit\nebFitLPS <- eBayes(fitsLPS)\nebFitUntreated <- eBayes(fitsUntreated)\nebFitUT.LPS <- eBayes(fitsUT.LPS)\n\n#Now get the bayesian stats for the UTvsLPS data set\nebFit.of.LPS <- eBayes(fits.of.LPS)\n###############################################################################################\n# use the topTable and decideTests functions to see the differentially expressed genes\n###############################################################################################\n\n# use topTable function to take a look at the hits (BH=benjamini hochberg?)\n#coef = which of the contrast matrix columns are you interested in?\n#number = how many genes are you interested in?\nmyTopHitsLPS <- topTable(ebFitLPS, adjust =\"BH\", coef=3, number=20, sort.by=\"logFC\")\nmyTopHitsLPS\nmyTopHitsUntreated <- topTable(ebFitUntreated, adjust =\"BH\", coef=3, number=20, sort.by=\"logFC\")\nmyTopHitsUntreated\nmyTopHitsUT.LPS <- topTable(ebFitUT.LPS, adjust =\"BH\", coef=2, number=20, sort.by=\"logFC\")\nmyTopHitsUT.LPS\n\nmyTopHits.of.LPS <- topTable(ebFit.of.LPS, adjust =\"BH\", coef=3, number=20, sort.by=\"logFC\")\nmyTopHits.of.LPS\n\n# use the 'decideTests' function to show Venn diagram for all diffexp genes for up to three comparisons\n# 0 = not differentially expressed, 1 = up, -1 = down. Now show me all the 1s. lfc = log fold change\nresultsLPS <- decideTests(ebFitLPS, method=\"global\", adjust.method=\"BH\", p.value=0.05, lfc=0.59)\n#stats <- write.fit(ebFitLPS)\nvennDiagram(resultsLPS, include=\"both\") #all pairwise comparisons on a B6 background\nresultsUntreated <- decideTests(ebFitUntreated, method=\"global\", adjust.method=\"BH\", p.value=0.05, lfc=0.59)\nvennDiagram(resultsUntreated, include=\"both\", cex=1) #all pairwise comparisons on a B6 background\n\nresultsUT.LPS <- decideTests(ebFitUT.LPS, method=\"global\", adjust.method=\"BH\", p.value=0.05, lfc=0.59)\nvennDiagram(resultsUT.LPS, include=\"both\", cex = 1)\n\n# take a look at what the results of decideTests looks like\nresultsLPS\nresultsUT.LPS\n\n# now pull out probeIDs from selected regions of the Venn diagram.  In this case, I want all genes in the venn. The columns refer to the contrast matrix\ndiffProbesLPS <- which(resultsLPS[,1] !=0 | resultsLPS[,2] !=0 | resultsLPS[,3] !=0)\nclass(diffProbesLPS)\ndiffProbesUntreated <- which(resultsUntreated[,1] !=0 | resultsUntreated[,2] !=0 | resultsUntreated[,3] !=0)\ndiffProbesUT.LPS <- which(resultsUT.LPS[,1] !=0 | resultsUT.LPS[,2] !=0 | resultsUT.LPS[,3] !=0)\n\n#before pulling out expression data for differentially expressed genes, convert matrix to eset with annotation\nlibrary(Biobase)\nmyEset.ALL <- new(\"ExpressionSet\", exprs = myCollapsed)\n\n# retrieve expression data for the probes from above\ndiffData.LPS <- myEset.ALL[resultsLPS[,1] !=0 | resultsLPS[,2] !=0 | resultsLPS[,3] !=0]\ndiffData.Untreated <- myEset.ALL[resultsUntreated[,1] !=0 | resultsUntreated[,2] !=0 | resultsUntreated[,3] !=0]\ndiffDataUT.LPS <- myEset.ALL[resultsUT.LPS[,1] !=0 | resultsUT.LPS[,2] !=0 | resultsUT.LPS[,3] !=0]\n\n#pull the expression data back out of the eset object\ndiffData.LPS <- exprs(diffData.LPS)\ndiffData.Untreated <- exprs(diffData.Untreated)\ndiffDataUT.LPS <- exprs(diffDataUT.LPS)\n\n#combine probeIDs, gene symbols and expression data for differentially expressed genes into one file\nwrite.table(cbind(diffProbesLPS, diffData.LPS),\"DiffGenesLPS.xls\", sep=\"\\t\", quote=FALSE)\nwrite.table(cbind(diffProbesUntreated, diffData.Untreated),\"DiffGenesUntreated.xls\", sep=\"\\t\", quote=FALSE)\n## why do we include diffProbes as one of the columns here? cause that's the one with all the weird numbers, no?\n\n# take a look at each expression matrix\ndim(diffData.LPS)\ndim(diffData.Untreated)\ndim(diffDataUT.LPS)\n\n#############################################################################################################\n\n### Step3b_dataWrangling_for Diff expressed genes\n\n#this script walks thorough some basic data wrangling for organizing expression data spreadsheets and ends with\n#how to create publication quality graphics from transcriptomic data generated (regardless of platform used)\n#to start this script you need a file with all your expression data and some non-redundant identifiers as row names (usually gene symbols)\n#you also need a study design file\n\n#for creating graphics, we'll use the ggplot2 and ggvis packages which employ a 'grammar of graphics' approach\n#load the packages\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggvis)\n\n#read in your data from a text file that contains genes symbols as rows, and samples as columns. \nmyDiffGenes.LPS <- read.delim(\"LPS.Cluster3.1.txt\", header=TRUE)\nhead(myDiffGenes.LPS)\n#myDiffGenes.LPS <- myDiffGenes.LPS[,-1]\n#subset data to get rid of column \"2\" = -2\n#myData <- myData[,-2]\n#make column 1 the row names of myData\n#row.names(myData) <- myData[,1]\n#myData <- myData[,-1]\n#head(myData)\n\n# [This is probably not necessary since myCollapsedData already has column headers, but for array data use this] column headers are a bit cumbersome, so we'll change these to something more human-readable\n#targets <- read.delim(\"Igor_Ripk3_BMMC_studyDesign_RNAseq.txt\", sep=\"\\t\", stringsAsFactors = FALSE)\n#sampleLabels <- as.character(paste(targets$cellType, targets$treatment, targets$phenotype, targets$rep, sep=\".\"))\n#colnames(myData) <- sampleLabels\n#head(myData)\ngeneSymbols <- (myDiffGenes.LPS[,1])\n#myCollapsedData.df <- as.data.frame(myCollapsedData)\n#head(myCollapsedData.df)\n\n#use the dplyr 'mutate' command to get averages and fold changes for all your replicates, dplyr only works on data frames and row names are not considered part of the table\nmyDiffGenes.LPS <- mutate(myDiffGenes.LPS,\n                          B6.untreated.AVG = (B6.untreated.1 + B6.untreated.2)/2,\n                          Ripk3.untreated.AVG = (Ripk3.untreated.1 + Ripk3.untreated.2)/2,\n                          Ripk3_Casp8.untreated.AVG = (Ripk3_Casp8.untreated.1 + Ripk3_Casp8.untreated.2)/2,\n                          B6.LPS_6hr.AVG = (B6.LPS_6hr.1 + B6.LPS_6hr.2)/2,\n                          Ripk3.LPS_6hr.AVG = (Ripk3.LPS_6hr.1 + Ripk3.LPS_6hr.2)/2,\n                          Ripk3_Casp8.LPS_6hr.AVG = (Ripk3_Casp8.LPS_6hr.1 + Ripk3_Casp8.LPS_6hr.2)/2,\n                          LogFC.Ripk3.LPS_6hr.vs.B6.LPS_6hr = (Ripk3.LPS_6hr.AVG - B6.LPS_6hr.AVG),\n                          LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr = (Ripk3_Casp8.LPS_6hr.AVG - Ripk3.LPS_6hr.AVG),\n                          LogFC.Ripk3_Casp8.LPS_6hr.vs.B6.LPS_6hr = (Ripk3_Casp8.LPS_6hr.AVG - B6.LPS_6hr.AVG),\n                          LogFC.Ripk3_Casp8.untreated.vs.Ripk3.untreated = (Ripk3_Casp8.untreated.AVG - Ripk3.untreated.AVG),\n                          LogFC.Ripk3.untreated.vs.B6.untreated = (Ripk3.untreated.AVG - B6.untreated.AVG),\n                          LogFC.Ripk3_Casp8.untreated.vs.B6.untreated = (Ripk3_Casp8.untreated.AVG - B6.untreated.AVG),\n                          geneSymbols=geneSymbols) # why do we have a column at the end with gene Symbols??\n\n#now look at this modified data table\n#row.names(myDiffGenes.LPS) <- geneSymbols\nhead(myDiffGenes.LPS)\nwrite.table(myDiffGenes.LPS, \"myCluster3.1.xls\", sep=\"\\t\", quote=FALSE)\n\n#use dplyr \"arrange\" and \"select\" functions to sort by LogFC column of interest (arrange)\n#and then display only the columns of interest (select) to see the most differentially expressed genes\nmyDiffGenes.LPS.sort.R3C8vR3 <- myDiffGenes.LPS %>%\n  arrange(desc(LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr)) %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr, Ripk3.LPS_6hr.AVG, Ripk3_Casp8.LPS_6hr.AVG) \nhead(myDiffGenes.LPS.sort.R3C8vR3)\nwrite.table(myDiffGenes.LPS.sort.R3C8vR3, \"myDiffGenes.LPS.sort.R3C8vR3.xls\", sep=\"\\t\", quote=FALSE)\n\nmyDiffGenes.LPS.sort.R3vB6 <- myDiffGenes.LPS %>%\n  arrange(desc(LogFC.Ripk3.LPS_6hr.vs.B6.LPS_6hr)) %>%\n  select(geneSymbols, LogFC.Ripk3.LPS_6hr.vs.B6.LPS_6hr, B6.LPS_6hr.AVG, Ripk3.LPS_6hr.AVG) \nhead(myDiffGenes.LPS.sort.R3vB6)\nwrite.table(myDiffGenes.LPS.sort.R3vB6, \"myDiffGenes.LPS.sort.R3vB6.xls\", sep=\"\\t\", quote=FALSE)\n\nmyDiffGenes.LPS.sort.R3C8vB6 <- myDiffGenes.LPS %>%\n  arrange(desc(LogFC.Ripk3_Casp8.LPS_6hr.vs.B6.LPS_6hr)) %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.B6.LPS_6hr, B6.LPS_6hr.AVG, Ripk3_Casp8.LPS_6hr.AVG) \nhead(myDiffGenes.LPS.sort.R3C8vB6)\nwrite.table(myDiffGenes.LPS.sort.R3C8vB6, \"myDiffGenes.LPS.sort.R3C8vB6.xls\", sep=\"\\t\", quote=FALSE)\n\n#use dplyr \"filter\" and \"select\" functions to pick out genes of interest (filter)\n#ways to tweek the 'select' function\n#use : between two column names to select all columns between\n#use 'contains', 'starts_with' or 'ends_with' to modify how you select\n#can refer to columns using exact name or numerical indicator\nmyDiffGenes.LPS.filter <- myDiffGenes.LPS %>%\n  filter(geneSymbols==\"Cebpb\" | geneSymbols==\"Bach1\") %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr, LogFC.Ripk3_Casp8.LPS_6hr.vs.B6.LPS_6hr) \nhead(myDiffGenes.LPS.filter)\n\n#another example using grep to match patterns - how do you filter multiple patterns of rows into one data table?\nmyDiffGenes.LPS.filter <- myDiffGenes.LPS %>%\n  #filter(grepl('Ccl', geneSymbols)) %>%\n  filter(grepl('Il', geneSymbols) | grepl('Tnf', geneSymbols) | grepl('Ccl', geneSymbols) | grepl('Cxcl', geneSymbols)) %>%\n  select(geneSymbols, LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr) \nhead(myDiffGenes.LPS.filter)\n\n#first reorder and clean up the data you want to graph\n#row.names(myCollapsedData.filter) <- myCollapsedData.filter[,1]\n#myCollapsedData.filter <- select(myCollapsedData.filter, -geneSymbols)\n#myCollapsedData.filter.transpose <- as.data.frame(t(myCollapsedData.filter))\n#cellType <- c(\"B1a\", \"B1b\", \"Mac\")\n#myCollapsedData.filter.transpose <- mutate(myData.filter.transpose, cellType, \nphenotype=c(\"naive\", \"naive\",\"naive\"))\n#myCollapsedData.filter.transpose\n\n#another way to set up for graphing...don't filter before transposing\n#myCollapsedData.graph <- select(myCollapsedData,-geneSymbols)\n#head(myCollapsedData.graph)\n#myCollapsedData.graph.transpose <- as.data.frame(t(myCollapsedData.graph))\n#dim(myCollapsedData.graph.transpose)\n\n#plot a simple bar graph - y=column of interest, x= row of interest from filtered table\nggplot(myDiffGenes.LPS.filter, aes(y=LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr)) +\n  geom_bar(aes(x=geneSymbols, fill=LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr), stat=\"identity\") +\n  theme(axis.text.x=element_text(angle=-45))\n\n#create a basic scatterplot using ggplot\nggplot(myDiffGenes.LPS, aes(x=Ripk3.LPS_6hr.AVG, y=Ripk3_Casp8.LPS_6hr.AVG)) +\n  geom_point(shape=1) +\n  geom_point(size=4)\n\n# ##Volcano plots\n# ##Highlight genes that have an absolute fold change > 2 and a p-value < Bonferroni cut-off\n# gene_list$threshold = as.factor(abs(gene_list$logFC) > 2 & gene_list$P.Value < 0.05/no_of_genes)\n# \n# ##Construct the volcano plot\n# ggplot(data=myData, aes(x=logFC, y=-log10(P.Value), colour=threshold)) +\n#   geom_point(alpha=0.4, size=1.75) +\n#   opts(legend.position = \"none\") +\n#   xlim(c(-10, 10)) + ylim(c(0, 15)) +\n#   xlab(\"log2 fold change\") + ylab(\"-log10 p-value\")\n\n#define a tooltip that shows gene symbol and Log2 expression data when you mouse over each data point in the plot\ntooltip <- function(data, ...) {\n  paste0(\"<b>\",\"Symbol: \", data$geneSymbols, \"</b><br>\",\n         \"Ripk3.LPS_6hr.AVG: \", data$Ripk3.LPS_6hr.AVG, \"<br>\",\n         \"Ripk3_Casp8.LPS_6hr.AVG: \", data$Ripk3_Casp8.LPS_6hr.AVG)\n}\n\n#plot the interactive graphic\nmyDiffGenes.LPS %>% \n  ggvis(x= ~Ripk3.LPS_6hr.AVG, y= ~Ripk3_Casp8.LPS_6hr.AVG, key := ~geneSymbols) %>% \n  layer_points(fill = ~LogFC.Ripk3_Casp8.LPS_6hr.vs.Ripk3.LPS_6hr) %>%\n  add_tooltip(tooltip)\n\n#####################################################################################\n\n#Step 5 HEATMAPS\n\n#this script creates detailed heatmaps from your differentially expressed genes\n#first part of script contains basic heatmap creation by reading in a file of a priori genes\n#second part of script uses all the differentially expressed genes you identified previously\n\n###################################################################################################\n# generate a heatmap of differentially expressed transcripts using the entire dataset\n###################################################################################################\n#LPS HEATMAPS\n\n#first let's generate a heatmap of diff expr genes in response to LPS treatment (contrast matrix.LPS - see above)\ndiffData.LPS.subset <- diffData.LPS[,c(7,8,9,10,11,12)]\nhr <- hclust(as.dist(1-cor(t(diffData.LPS.subset), method=\"pearson\")), method=\"average\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(diffData.LPS.subset, method=\"spearman\")), method=\"complete\") #cluster columns by spearman correlation\n# Cut the resulting tree and create color vector for clusters.  Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters\ndim(diffData.LPS.subset)\n#cutree will cut to give 7 groups if you do k=7\nmycl <- cutree(hr, k=4)\nmycolhc <- rainbow(length(unique(mycl)), start=0.1, end=0.9) \nmycolhc <- mycolhc[as.vector(mycl)] \n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]).\nmyheatcol <- greenred(75)\nlibrary(RColorBrewer)\n\n#plot the hclust results as a heatmap (arg1=datatable, Rowv=what do you want in your rows?)\n#heatmap.2(diffData.LPS, Rowv=as.dendrogram(hr), Colv=NA, \n          #col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n          #density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n          #cexRow=1, cexCol=1, margins=c(8,30)) \n#notice that the heatmap includes ALL the columns from your dataset\n\nheatmap.2(diffData.LPS.subset, Rowv=as.dendrogram(hr), Colv=NA, \n          col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n          density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n          cexRow=1, cexCol=1, margins=c(8,30)) \n\n#now find out what your clusters are \nnames(mycolhc) <- names(mycl) \nbarplot(rep(10, max(mycl)), \n        col=unique(mycolhc[hr$labels[hr$order]]), \n        horiz=T, names=unique(mycl[hr$order])) # Prints color key for cluster assignments. The numbers next to the color boxes correspond to the cluster numbers in 'mycl'.\n\n#Now repeat this process, but with your biological replicates averaged\nhead(diffData.LPS)\nlibrary(limma)\ncolnames(diffData.LPS) <- myGroups\n#cannot do this for the subset do it for whole thing first\ndim(diffData.LPS)\n#rownames(diffData.LPS) <- diffProbesLPS\nhead(diffData.LPS)\n#dim(diffProbesLPS)\ndiffData.LPS.AVG <- avearrays(diffData.LPS, ID=colnames(diffData.LPS))\nhead(diffData.LPS.AVG)\ndim(diffData.LPS.AVG)\n\n#then rerun the heatmap script above using diffData.AVG as input instead of diffData\n\ndiffData.LPS.subset.AVG <- diffData.LPS.AVG[,c(4,5,6)]\n\nhr <- hclust(as.dist(1-cor(t(diffData.LPS.subset.AVG), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(diffData.LPS.subset.AVG, method=\"spearman\")), method=\"complete\") #cluster columns by spearman correlation\n# Cut the resulting tree and create color vector for clusters.  Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters\ndim(diffData.LPS.subset.AVG)\n#cutree will cut to give 7 groups if you do k=7\nmycl <- cutree(hr, k=6)\nmycolhc <- rainbow(length(unique(mycl)), start=0.1, end=0.9) \nmycolhc <- mycolhc[as.vector(mycl)] \n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]).\nmyheatcol <- greenred(75)\nlibrary(RColorBrewer)\nheatmap.2(diffData.LPS.subset.AVG, Rowv=as.dendrogram(hr), Colv=NA, \n          col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n          density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n          cexRow=1, cexCol=1, margins=c(8,30), key=T) \n#clusters 4, 3, 2, 1 from top down.\n#clusters 5, 4, 3, 6, 2, 1 from top down.\n\n#select sub-clusters of co-regulated transcripts for downstream analysis\n\nclid <- c(3) \nysub <- diffData.LPS.subset.AVG[names(mycl[mycl%in%clid]),] \nhrsub <- hclust(as.dist(1-cor(t(ysub), method=\"pearson\")), method=\"average\") \nclusterIDs <- data.frame(Labels=rev(hrsub$labels[hrsub$order]))\nclusterIDs <- as.vector(t(clusterIDs))\nheatmap.2(ysub, Rowv=as.dendrogram(hrsub), Colv=NA, labRow=NA, col=myheatcol, scale=\"row\", density.info=\"none\", trace=\"none\", RowSideColors=mycolhc[mycl%in%clid], margins=c(8,30)) # Create heatmap for chosen sub-cluster.\n\n#retrieve gene symbols and entrezIDs for selected cluster and print out to an excel spreadsheet for downstream applications (i.e. GO enrichment in DAVID)\nwrite.table(clusterIDs, \"LPS.AVG.Cluster3.6groups.xls\", sep=\"\\t\", quote=FALSE)\n\n####################################################################################################################################################\n\n#UNTREATED HEATMAPS\n\n#first let's generate a heatmap of diff expr genes for untreated samples (contrast matrix.untreated - see above)\ndiffData.Untreated.subset <- diffData.Untreated[,c(1,2,3,4,5,6)]\nhr <- hclust(as.dist(1-cor(t(diffData.Untreated.subset), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(diffData.Untreated.subset, method=\"spearman\")), method=\"complete\") #cluster columns by spearman correlation\n# Cut the resulting tree and create color vector for clusters.  Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters\ndim(diffData.Untreated.subset)\n#cutree will cut to give 7 groups if you do k=7\nmycl <- cutree(hr, k=6)\nmycolhc <- rainbow(length(unique(mycl)), start=0.1, end=0.9) \nmycolhc <- mycolhc[as.vector(mycl)] \n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]).\nmyheatcol <- greenred(75)\nlibrary(RColorBrewer)\n\n#plot the hclust results as a heatmap (arg1=datatable, Rowv=what do you want in your rows?)\n#heatmap.2(diffData.LPS, Rowv=as.dendrogram(hr), Colv=NA, \n#col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n#density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n#cexRow=1, cexCol=1, margins=c(8,30)) \n#notice that the heatmap includes ALL the columns from your dataset\n\nheatmap.2(diffData.Untreated.subset, Rowv=as.dendrogram(hr), Colv=NA, \n          col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n          density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n          cexRow=1, cexCol=1, margins=c(8,30)) \n#clusters 6,2,5,4,3,1 from top down.\n\n#now find out what your clusters are \nnames(mycolhc) <- names(mycl) \nbarplot(rep(10, max(mycl)), \n        col=unique(mycolhc[hr$labels[hr$order]]), \n        horiz=T, names=unique(mycl[hr$order])) # Prints color key for cluster assignments. The numbers next to the color boxes correspond to the cluster numbers in 'mycl'.\n\n#Now repeat this process, but with your biological replicates averaged\nhead(diffData.Untreated)\nlibrary(limma)\ncolnames(diffData.Untreated) <- myGroups\n#cannot do this for the subset do it for whole thing first\ndim(diffData.Untreated)\n#rownames(diffData.LPS) <- diffProbesLPS\nhead(diffData.Untreated)\n#dim(diffProbesLPS)\ndiffData.Untreated.AVG <- avearrays(diffData.Untreated, ID=colnames(diffData.Untreated))\nhead(diffData.Untreated.AVG)\ndim(diffData.Untreated.AVG)\n\n#then rerun the heatmap script above using diffData.AVG as input instead of diffData\n\ndiffData.Untreated.subset.AVG <- diffData.Untreated.AVG[,c(1,2,3)]\n\nhr <- hclust(as.dist(1-cor(t(diffData.Untreated.subset.AVG), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(diffData.Untreated.subset.AVG, method=\"spearman\")), method=\"complete\") #cluster columns by spearman correlation\n# Cut the resulting tree and create color vector for clusters.  Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters\ndim(diffData.Untreated.subset.AVG)\n#cutree will cut to give 7 groups if you do k=7\nmycl <- cutree(hr, k=4)\nmycolhc <- rainbow(length(unique(mycl)), start=0.1, end=0.9) \nmycolhc <- mycolhc[as.vector(mycl)] \n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]).\nmyheatcol <- greenred(75)\nlibrary(RColorBrewer)\nheatmap.2(diffData.Untreated.subset.AVG, Rowv=as.dendrogram(hr), Colv=NA, \n          col=myheatcol, scale=\"row\", labRow=NA, labCol=NA,\n          density.info=\"none\", trace=\"none\", RowSideColors=mycolhc, \n          cexRow=1, cexCol=1, margins=c(8,30), key=T) \n#clusters 4,3,2,1 from top down.\n\n###############################################################################################\n#select sub-clusters of co-regulated transcripts for downstream analysis\n###############################################################################################\nclid <- c(4) \nysub <- diffData.Untreated.subset.AVG[names(mycl[mycl%in%clid]),] \nhrsub <- hclust(as.dist(1-cor(t(ysub), method=\"pearson\")), method=\"average\") \nclusterIDs <- data.frame(Labels=rev(hrsub$labels[hrsub$order]))\nclusterIDs <- as.vector(t(clusterIDs))\nheatmap.2(ysub, Rowv=as.dendrogram(hrsub), Colv=NA, labRow=NA, col=myheatcol, scale=\"row\", density.info=\"none\", trace=\"none\", RowSideColors=mycolhc[mycl%in%clid], margins=c(20,25)) # Create heatmap for chosen sub-cluster.\n\n#retrieve gene symbols and entrezIDs for selected cluster and print out to an excel spreadsheet for downstream applications (i.e. GO enrichment in DAVID)\nwrite.table(clusterIDs, \"Untreated.AVG.Cluster4.xls\", sep=\"\\t\", quote=FALSE)\n\n###############################################################################################\n#read in your own data to make a heatmap\n###############################################################################################\n\nmySelectedHeatmap <- read.delim(\"LPS.Cluster3.1.txt\", sep=\"\\t\", stringsAsFactors = FALSE, header=TRUE, row.names=1)\nmySelectedHeatmap <- mySelectedHeatmap[,c(-1,-2,-3,-4,-5,-6)]\nmySelectedHeatmap <- as.matrix(mySelectedHeatmap)\n#carry out hclust on the collapsed data matrix to generate a distance matrix for clustering\n\nhr <- hclust(as.dist(1-cor(t(mySelectedHeatmap), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc <- hclust(as.dist(1-cor(mySelectedHeatmap, method=\"spearman\")), method=\"average\") #cluster columns by spearman correlation\ndim(mySelectedHeatmap)\nmycl <- cutree(hr, k=2)\nmycolhc <- rainbow(length(unique(mycl)), start=0.1, end=0.9) \nmycolhc <- mycolhc[as.vector(mycl)] \n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]).\nmyheatcol <- greenred(75)\nlibrary(RColorBrewer)\n#Rowv=NA maintains the order of the rows you have in your data table.\nheatmap.2(mySelectedHeatmap, Rowv=NA, Colv=NA, col=myheatcol, \n          scale=\"row\", density.info=\"none\", trace=\"none\", labCol=NA, \n          RowSideColors=mycolhc, labRow=NULL,\n          cexRow=1.5, cexCol=1, margins=c(5,30), key=T) # Creates heatmap for entire data set where the obtained clusters are indicated in the color bar.\n\n###############################################################################################\n#yet another way is to first generate a table using dplyr 'filter' and 'select' to get table for heatmap\n###############################################################################################\nmyData.filter <- myData %>%\n  filter((abs(Ecdysone.vs.PBS_18hr_gut) >= 1) | (abs(Ecdysone.vs.PBS_5hr_gut) >= 1)) %>%\n  select(geneID, Ecdysone.vs.PBS_5hr_carcass, Ecdysone.vs.PBS_18hr_carcass, Ecdysone.vs.PBS_5hr_gut, Ecdysone.vs.PBS_18hr_gut)\nhead(myData.filter)\n",
    "created" : 1433293345503.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "671146176",
    "id" : "34132DE1",
    "lastKnownWriteTime" : 1443458777,
    "path" : "~/Git/TranscriptomicsWorkshop.github.io/R_scripts/myAnalysis.R",
    "project_path" : "myAnalysis.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}