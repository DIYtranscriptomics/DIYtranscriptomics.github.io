{
    "contents" : "#########################################################################################################################\n#prepare your data for gene set analysis\n#########################################################################################################################\n#you'll want to have already read-in your raw microarray data,\n#normalized your data,\n#carried out differential expression analysis using limma,\n#and perhaps even generated some a priori lists of genes you're interested in.\n\n#for the purposes of this script we'll want several objects generated by the steps above:\n#1) your normalized data batch object (normData)\n#2) your experimental design file that you created during differential expression analysis\n#3) your contrast matrix\n#4) your moderated T statistics produced by the eBayes analysis with Limma\n#5) Gene sets that you'd like to test for enrichment in your array data\n#these gene sets can be 'custom' made based on your specific interests,\n#or they can be downloaded from gene signature databases such as MSigDB or GeneSignatureDB\n\n#generally speaking, there are two approaches for gene set testing.  \n#both are outlined below, with several options present for each approach\n\n\n#########################################################################################################################\n# GENERAL APPROACH 1: SELF-CONTAINED GENE SET TESTING\n#several tools available for this, many within the Limma package\n#use these tests when you want to know whether one (or a few) selected gene sets are enriched 'signatures' on your array\n#########################################################################################################################\nlibrary(limma)\n\n#take a look at the matrix of moderated T statistics produced by the eBayes function that you used during differential expression analysis with Limma\n#one approach to Gene Set Testing is to use the ebayes statistics as the basis for determining whether a set of probes is overrepresented in up- or down-regulated genes\nhead(ebFit.treatment_late$t)\n\n#OPTION 1: use GeneSetTest function (Limma)\n#the 'probeIDs' object here is a custom 'a priori' list of probset IDs generated from the end of my Limma script\n#the output from the geneSetTest function is a P value that indicates whether the probe set is enriched or not\ngeneSetTest(probeIDs,ebFit.treatment_late$t[,3],\"greater\") #use \"greater\" or \"less\" to see if the gene set is enriched in up or down regulated genes\n\n#OPTION 2a: use ROAST function (Limma)\n#the output from ROAST gives three pvals, each testing whether genes are up, down or mixed (differentially expressed without regard to direction)\nroast(normData, probeIDs, design, contrast.matrix.treatment_late[,1], nrot=99) \n\n#######NEED TO FIX THIS SECTION DOWN TO GSVA\n#OPTION 2b: use mROAST function (Limma) for testing enrichment of more than one gene set\n#this is essentially the same as running ROAST multiple times and then just correcting for multiple testing at the end\n#first, load a gene set database list\nload(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/mouse_c5.rdata\")\nload(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/GeneSigDBv4.0.RData\")\n\n#convert your entire array into an index of lists, by matching symbols to your array\nmouseSymbols <- fit$genes$Symbol\nupperSymbols <- toupper(mouseSymbols) #tolower to convert symbols to mouse\nfit$genes$Symbol <-upperSymbols\n\nmouse.c5 <- symbols2indices(Mm.gmtl.c5, fit$genes$Symbol, remove.empty=T)\nmroast.res <- mroast(normData, mouse.c5, design, contrast.matrix.treatment_late[,3], nrot=99) \ndim(mroast.res)\nhead(mroast.res)\ntail(mroast.res)\n\nclass(broadSet.Treg)\n\n#If you're testing one or two Gene Sets, the enrichment 'profile' can be visually plotted on the scale of moderated T stats as a 'barcodeplot' (Limma)\n#change the subset to indicate which contrast in your matrix you'd like to display the bayes stats for\nbarcodeplot(ebFit.treatment_late$t[,3], probeIDs)\n\n\n#############################################################################################################################\n#competitive Gene Set testing (i.e. 'GSEA'), using CAMERA, Romer, or GSEAlm\n#this allows you to take a database or collection of gene sets (such as MSigDB or GeneSigDB) and pit them against each other\n#the results tells you which gene sets were the most enriched in the up/down regulated genes for each contrast (pairwise comparison)\n#############################################################################################################################\n\n#OPTION 1: use CAMERA function (Limma)\ncamera.res <- camera(normData, mouse.c5, design, contrast.matrix.treatment_late[,1])\ndim(camera.res)\nhead(camera.res)\ntail(camera.res)\n\n#OPTION 2: use ROMER function (Limma)\nromer.res <- romer(mouse.c5, normData, design, contrast.matrix.treatment_late[,1])\ndim(romer.res)\nhead(romer.res)\ntail(romer.res)\n\n#OPTION 3: uses the SPIA package - this is a bit different from all the above options, but is similar in concept. \n# SPIA is designed to identify signaling pathways that are overrepresented in your set of differentially expressed genes\n# takes two files as input: 1) your diff expressed genes; 2) ALL your genes as the background\n# SPIA is unique in that it weights each component of a signaling pathway in terms of its importance in propagating signal (i.e. it factors in pathway 'topology')\n\n\n\nlibrary(iBBiG)\nbinMat<-makeArtificial()\n#plot(binMat)\nres<- iBBiG(binMat@Seeddata, nModules=10)\nx11(); plot(res)\nstatClust(res,binMat)\n\n###########################################################################################################################################\n#carry out the equivalent of ***single sample*** Gene Set Enrichment Analysis (ssGSEA) using Broad/MsigDB, GeneSigDB, or any list of gene sets\n#this is a bit different than using CAMERA or ROMER, in that ssGSEA doesn't care about your contrasts (pairwise comparisons)\n#instead, ssGSEA ranks genes from highest absolute expression to lowest for EACH of your samples.\n#GSEA is then carried out on each ranked list\n###########################################################################################################################################\n#You'll need to download the .GMT files to your computer directly from from the MSigDB website (I choose the gene symbol files).  \n#These can be found at:  http://www.broadinstitute.org/gsea/msigdb/collections.jsp\n#place these files in a folder on your computer\n#the first part of this script points to these files, so be sure to change these lines to match the directory on your computer.\n#NOTE: all MSigDB files are HUMAN genes, so you shouldn't query a mouse array against them\n#if you're working with mouse array data, use MSigDB files that have been mapped to human/mouse orthologs. These can be found at:\n#http://bioinf.wehi.edu.au/software/MSigDB/\n\n\n#Load the necessary packages\nlibrary(GSEABase)\nlibrary(GSVA)\n\n#read in one or multiple MsigDB .GMT files (must've already downloaded these to your computer)\n#each file is a vector of lists in which each list contains all the genes associated with a particular pathway\n\n#MsigDB set C7 contains list of genes associated with immunological signatures\nbroadSet.C7 <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c7.all.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\n#set C6 contains sets of genes that are oncogenic signatures\nbroadSet.C6 <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c6.all.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\n#set C5 contains sets of genes associated with different GO terms\nbroadSet.C5.ALL <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c5.all.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C5.BP <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c5.bp.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C5.MF <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c5.mf.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\n#set C3 contains lists of targets for TFs\nbroadSet.C3.TFT <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c3.tft.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\n#set C2 contains pathways and chemical/genetic perturbations\nbroadSet.C2.ALL <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c2.all.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C2.KEGG <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c2.cp.kegg.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C2.BIOCARTA <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c2.cp.biocarta.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C2.REACTOME <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c2.cp.reactome.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C2.PERTURBATIONS <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c2.cgp.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\nbroadSet.C2.CANONICAL <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/c2.cp.v4.0.symbols.gmt\", geneIdType=SymbolIdentifier())\n\n#alternatively, you could download and read-in the ENTIRE MSigDB.  I prefer not to do this....too cumbersome.\nbroad.ALL <- getGMT(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/msigdb_v4.0.symbols.gmt\")\n\n#Treg specific pathways (generated by searching MSigDB for the term 'Treg')\n#includes 8 GEO entries that were used to generate 112 different signatures (UP and DOWN signatures for many different pairwise comparisons)\n#note, the file that is returned by this search needs an empty line added at the end.\nbroadSet.Treg <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/TregSearch.gmt\", geneIdType=SymbolIdentifier())\n\n#gene sets from experiments with exhausted T cells\nbroadSet.Exhausted <- getGmt(\"/Users/danielbeiting/Documents/R_scripts/MSigDB_files/exhaustedSearch.gmt\", geneIdType=SymbolIdentifier())\n\n#Calculate the % overlap between all the gene sets in your database and represent as a correlation matrix\nlibrary(lattice)\nTregOverlap <- computeGeneSetsOverlap(broadSet.Treg, upperSymbols)\nrgb.palette <- colorRampPalette(c(\"blue\", \"red\", \"yellow\"), space = \"rgb\")\nx11(); levelplot(TregOverlap, main=\"Treg geneset correlation matrix\", xlab=\"\", ylab=\"\", col.regions=rgb.palette(1000), cuts=100, cexRow=0.5, cexCol=1, margins=c(10,10))\n\n###############################################################################################\n#now that you've read in the database files, you'll need to read-in your normalized gene expression data\n#if starting with a data matrix, first convert to an expressionSet object using the Biobase package\n###############################################################################################\n\n#read in a matrix of gene expression for your entire array\n#make sure to have gene symbols in all caps (coerced to human) \n#also need to collapse rows so that there are no duplicate row names.  Do this using either excel the collapseRows function in the WGCNA package\n#finally remove the NA collapsed row, since R will read this as a missing value, which is not allowed (I usually replace with \"NOTAGENE\")\nlibrary(Biobase)\nmyDataMatrix <- read.delim(\"Treg.normalizedData_late.txt\", row.names = 1, header=TRUE)\nhead(myDataMatrix)\nmyDataMatrix <- as.matrix(myDataMatrix)\nmyEset <- new(\"ExpressionSet\", exprs = myDataMatrix)\n\n\n###############################################################################################\n#run GSVA on the expressionSet data object\n#be aware that if you choose a large MsigDB file here, this step may take a while\n###############################################################################################\n#convert your geneSetCollections into lists using the 'geneIds' function\nbroadSet.Treg <- geneIds(broadSet.Treg)\nbroadSet.Exhausted <- geneIds(broadSet.Exhausted)\nbroadSet.C7 <- geneIds(broadSet.C7)\nbroadSet.C3.TFT <- geneIds(broadSet.C3.TFT)\nbroadSet.C5.BP <- geneIds(broadSet.C5.BP)\n\nTreg.res <- gsva(myDataMatrix, broadSet.Treg, min.sz=5, max.sz=500, verbose=TRUE, method=\"gsva\")$es.obs #options for method are \"gsva\", ssgsea', \"zscore\" or \"plage\"\nExhausted.res <- gsva(myDataMatrix, broadSet.Exhausted, min.sz=5, max.sz=500, verbose=TRUE, method=\"gsva\")$es.obs #options for method are \"gsva\", ssgsea', \"zscore\" or \"plage\"\nC7.res <- gsva(myDataMatrix, broadSet.C7, min.sz=5, max.sz=500, verbose=TRUE, method=\"gsva\")$es.obs #options for method are \"gsva\", ssgsea', \"zscore\" or \"plage\"\nC3.TFT.res <- gsva(myDataMatrix, broadSet.C3.TFT, min.sz=5, max.sz=500, verbose=TRUE, method=\"gsva\")$es.obs #options for method are \"gsva\", ssgsea', \"zscore\" or \"plage\"\nC5.BP.res <- gsva(myDataMatrix, broadSet.C5.BP, min.sz=5, max.sz=500, verbose=TRUE, method=\"gsva\")$es.obs #options for method are \"gsva\", ssgsea', \"zscore\" or \"plage\"\n\n###############################################################################################################################################\n#use Limma to select gene sets that are differentially enriched (based on GSVA analysis above) between your two conditions of interest\n###############################################################################################################################################\n#define a pval and logFC cutoff to be used later in the enrichment analysis\nadjPvalueCutoff <- 0.05\nlogFCcutoff <- log2(0.59)\n\n#use limma to apply a linear model to the data\nlibrary(limma)\ntargets <- readTargets(\"Treg_studyDesign3.txt\", sep=\"\\t\")\ntargets\nfactorial <- paste(targets$treatment)\nfactorial <- factor(factorial)\nfactorial\ndesign <- model.matrix(~0+factorial)\ncolnames(design) <- levels(factorial)\ndesign\n\nfit.Treg <- lmFit(Treg.res, design)\nfit.Exhausted <- lmFit(Exhausted.res, design)\nfit.C7 <- lmFit(C7.res, design)\nfit.C3.TFT <- lmFit(C3.TFT.res, design)\nfit.C5.BP <- lmFit(C5.BP.res, design)\n\n# set up a contrast matrix based on the pairwise comparisons of interest\ncontrast.matrix <- makeContrasts(IL27effect = IL27 - neutral, levels=design)\n\n# use topTable and decideTests functions of Limma to identify the differentially enriched gene sets\nres.Treg <- decideTests(fit.Treg, p.value=adjPvalueCutoff, lfc=logFCcutoff)\nres.Exhausted <- decideTests(fit.Exhausted, p.value=adjPvalueCutoff, lfc=logFCcutoff)\nres.C7 <- decideTests(fit.C7, p.value=adjPvalueCutoff, lfc=logFCcutoff)\nres.C3.TFT <- decideTests(fit.C3.TFT, p.value=adjPvalueCutoff)\nres.C5.BP <- decideTests(fit.C5.BP, p.value=adjPvalueCutoff)\n\n#the summary of the decideTests result shows how many sets were enriched in induced and repressed genes in all sample types\nsummary(res.Treg)\nsummary(res.Exhausted)\nsummary(res.C7)\nsummary(res.C3.TFT)\nsummary(res.C5.BP)\n\n\n# extract the expression data matrix from the GSVA result and convert to an expressionSet object \nmyEset.Treg <- new(\"ExpressionSet\", exprs = Treg.res)\nmyEset.C7 <- new(\"ExpressionSet\", exprs = C7.res)\n\n#link the eset to annotation data\nannotation(myEset.Treg) <- \"lumiMouseAll.db\"\nannotation(myEset.C7) <- \"lumiMouseAll.db\"\n\n# pull out the GO gene sets that are differentially enriched between the two groups\ndiffSets.C7 <- myEset.C7[res.C7[,1] !=0 | res.C7[,2] !=0]\ndiffSets.C7 <- exprs(diffSets.C7)\n\ndiffSets.Treg <- myEset.Treg[res.Treg[,1] !=0 | res.Treg[,2] !=0]\ndiffSets.Treg <- exprs(diffSets.Treg)\n\ndiffSets.Exhausted <- myEset.Treg[res.Exhausted[,1] ==0 | res.Exhausted[,2] ==0]\ndiffSets.Exhausted <- exprs(diffSets.Exhausted)\n\nhead(diffSets.C7)\nhead(diffSets.Treg)\n\nsetNames.C7 <- rownames(diffSets.C7)\nsetNames.Treg <- rownames(diffSets.Treg)\nsetNames.Exhausted <- rownames(diffSets.Exhausted)\n\n\n###############################################################################################\n#make a heatmap of differentially enriched gene sets\n###############################################################################################\nhr.C7 <- hclust(as.dist(1-cor(t(diffSets.C7), method=\"pearson\")), method=\"complete\") #cluster rows by pearson correlation\nhc.C7 <- hclust(as.dist(1-cor(diffSets.C7, method=\"spearman\")), method=\"complete\") #cluster columns by spearman correlation\n\n# Cut the resulting tree and create color vector for clusters.  Vary the cut height to give more or fewer clusters, or you the 'k' argument to force n number of clusters\nlibrary(RColorBrewer)\nmycl.C7 <- cutree(hr.C7, k=2)\nmycolhc.C7 <- rainbow(length(unique(mycl.C7)), start=0.1, end=0.9) \nmycolhc.C7 <- mycolhc.C7[as.vector(mycl.C7)] \n\n#load the gplots package for plotting the heatmap\nlibrary(gplots) \n#assign your favorite heatmap color scheme. Some useful examples: colorpanel(40, \"darkblue\", \"yellow\", \"white\"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,\"Blues\")[-1]). Type demo.col(20) to see more color schemes.\nmyheatcol <- greenred(75)\n#plot the hclust results as a heatmap\nx11();heatmap.2(diffSets.Exhausted, Rowv=NA, Colv=NA, col=myheatcol, scale=\"row\", labRow=setNames.Exhausted, density.info=\"none\", trace=\"none\", labCol = sampleLabels.NeutralIL27, cexRow=0.9, cexCol=1, margins=c(10,25)) # Creates heatmap for entire data set where the obtained clusters are indicated in the color bar.\n\n#parse out interesting subclusters from CANONICAL \nx11(); heatmap.2(diffSets.CANONICAL, Rowv=NA, Colv=NA, col=myheatcol, scale=\"row\", labRow=setNames.CANONICAL, density.info=\"none\", trace=\"none\", RowSideColors=mycolhc.CANONICAL, labCol = sampleLabels.ALL, cexRow=0.75, cexCol=1, margins=c(10,10)) # Creates heatmap for entire data set where the obtained clusters are indicated in the color bar.\nx11(height=6, width=2); names(mycolhc.REACTOME) <- names(mycl.REACTOME); barplot(rep(10, max(mycl.REACTOME)), col=unique(mycolhc.REACTOME[hr.REACTOME$labels[hr.REACTOME$order]]), horiz=T, names=unique(mycl.REACTOME[hr.REACTOME$order])) # Prints color key for cluster assignments. The numbers next to the color boxes correspond to the cluster numbers in 'mycl'.\nclid.CANONICAL <- c(2,2); ysub <- diffSets.CANONICAL[names(mycl.CANONICAL[mycl.CANONICAL%in%clid.CANONICAL]),]; hrsub <- hclust(as.dist(1-cor(t(ysub), method=\"pearson\")), method=\"complete\") \nx11(); heatmap.2(ysub, Rowv=as.dendrogram(hrsub), Colv=NA, col=myheatcol, scale=\"row\", density.info=\"none\", trace=\"none\", RowSideColors=mycolhc.CANONICAL[mycl.CANONICAL%in%clid.CANONICAL], labCol = sampleLabels.ALL, labRow=setNames.CANONICAL, cexRow=0.75, cexCol=1, margins=c(10,10)) # Create heatmap for chosen sub-cluster.\n\n\n#look at cluster assignments\nx11(height=6, width=2); names(mycolhc.PERTURBATIONS) <- names(mycl.PERTURBATIONS); barplot(rep(10, max(mycl.PERTURBATIONS)), col=unique(mycolhc.PERTURBATIONS[hr.PERTURBATIONS$labels[hr.PERTURBATIONS$order]]), horiz=T, names=unique(mycl.PERTURBATIONS[hr.PERTURBATIONS$order])) # Prints color key for cluster assignments. The numbers next to the color boxes correspond to the cluster numbers in 'mycl'.\nx11(height=6, width=2); names(mycolhc.CANONICAL) <- names(mycl.CANONICAL); barplot(rep(10, max(mycl.CANONICAL)), col=unique(mycolhc.CANONICAL[hr.CANONICAL$labels[hr.CANONICAL$order]]), horiz=T, names=unique(mycl.CANONICAL[hr.CANONICAL$order])) # Prints color key for cluster assignments. The numbers next to the color boxes correspond to the cluster numbers in 'mycl'.\n\n#print your enrichment results to an excel spreadsheet\nwrite.table(diffSets, \"diffSets_GO_BP_GSEA.xls\", sep=\"\\t\", quote=FALSE)\n\n###############################################################################################\n#select sub-clusters of co-regulated transcripts for downstream analysis\n###############################################################################################\n#subclusters from CANONICAL gene set collection\n\n\nclid.REACTOME <- c(7,7); ysub <- diffSets.REACTOME[names(mycl.REACTOME[mycl.REACTOME%in%clid.REACTOME]),]; hrsub <- hclust.REACTOME(as.dist(1-cor(t(ysub), method=\"pearson\")), method=\"complete\") \n\n\nheatmap.2(ysub, Rowv=as.dendrogram(hrsub), Colv=NA, col=myheatcol, scale=\"row\", labRow=NA, density.info=\"none\", trace=\"none\", RowSideColors=mycolhc[mycl%in%clid], labCol = sampleLabels.ALL, cexRow=0.75, cexCol=1, margins=c(10,10)) # Create heatmap for chosen sub-cluster.\n\n#print out row labels in same order as shown in the heatmap\nclusterIDs <- data.frame(Labels=rev(hrsub$labels[hrsub$order]))\nclusterIDs <- as.vector(t(clusterIDs))\n#retrieve gene symbols and entrezIDs for selected cluster and print out to an excel spreadsheet for downstream applications (i.e. GO enrichment in DAVID)\nmyCluster <- cbind(getSYMBOL(clusterIDs, \"lumiHumanAll.db\"), getEG(clusterIDs, \"lumiHumanAll.db\"))\nwrite.table(myCluster, \"Cluster3.xls\", sep=\"\\t\", quote=FALSE)\n\n##############################################################################\n#find all genes on the array that are associated with a specific GO term(s) \n##############################################################################\nrequire(lumiHumanAll.db)\nGOterms <- as.list(lumiHumanAllGO2PROBE)\n\n#retrieve probeset IDs for each of the GO terms of interest\nisTransElong <- GOterms$\"GO:0006414\"\nOxBurst <- GOterms$\"GO:0045730\"\nROSmetabolism <- GOterms$\"GO:0072539\"\nSODactivity <- GOterms$\"GO:0004784\"\n\n#if more than one term was queried above, concatenate the results to one character vector\nmyGOterms <- c(OxBurst, ROSmetabolism, SODactivity)\n\n#filter your array data using the list of probeset IDs that you just generated\neset1 <- myEset[featureNames(myEset) %in% myGOterms] #myEset refers to your normalized, batch-adjusted data matrix\nmyFilteredExprs <- exprs(eset1)\ndim(myFilteredExprs)\nprobeIDs <- rownames(myFilteredExprs)\n#make a excel table of the retrieved data for your GO terms of interest\nmySelectedGenes <- getSYMBOL(probeIDs, \"lumiHumanAll.db\")\nmySelectedGenes <- as.matrix(mySelectedGenes)\nwrite.table(cbind(mySelectedGenes, myFilteredExprs),\"Selected_GO.xls\", sep=\"\\t\", quote=FALSE)\n",
    "created" : 1433292992575.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "695904412",
    "id" : "B2157D79",
    "lastKnownWriteTime" : 1433293088,
    "path" : "~/Git/TranscriptomicsWorkshop.github.io/R_scripts/Step6_geneSetAnalysis.R",
    "project_path" : "Step6_geneSetAnalysis.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}